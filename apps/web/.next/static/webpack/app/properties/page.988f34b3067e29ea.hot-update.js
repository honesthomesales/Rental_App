"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/properties/page",{

/***/ "(app-pages-browser)/../../packages/api/dist/services/tenants.js":
/*!***************************************************!*\
  !*** ../../packages/api/dist/services/tenants.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TenantsService = void 0;\nconst client_1 = __webpack_require__(/*! ../client */ \"(app-pages-browser)/../../packages/api/dist/client.js\");\nclass TenantsService {\n    /**\n     * Get all tenants with optional filtering\n     */ static async getAll(filters) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            let query = supabase.from(\"RENT_tenants\").select(\"*\").order(\"created_at\", {\n                ascending: false\n            });\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get a tenant by ID\n     */ static async getById(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenant, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", id).single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch property\n            let property = null;\n            if (tenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                property = propData;\n            }\n            // Fetch leases\n            const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                ascending: false\n            });\n            const tenantWithRelations = {\n                ...tenant,\n                properties: property,\n                leases: leasesData || []\n            };\n            return (0, client_1.createApiResponse)(tenantWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Create a new tenant\n     */ static async create(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the data being sent\n            console.log(\"TenantsService.create - Input data:\", tenantData);\n            // Only send the columns that actually exist in the RENT_tenants table\n            const insertData = {\n                property_id: tenantData.property_id,\n                first_name: tenantData.first_name,\n                last_name: tenantData.last_name,\n                email: tenantData.email,\n                phone: tenantData.phone,\n                monthly_rent: tenantData.monthly_rent,\n                lease_start_date: tenantData.lease_start_date,\n                lease_end_date: tenantData.lease_end_date,\n                notes: tenantData.notes\n            };\n            console.log(\"TenantsService.create - Insert data (filtered):\", insertData);\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                insertData\n            ]).select(\"*\").single();\n            if (error) {\n                console.error(\"TenantsService.create - Supabase error:\", error);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            console.log(\"TenantsService.create - Success, created tenant:\", data);\n            // Return simple response without additional data for now\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            console.error(\"TenantsService.create - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Update an existing tenant\n     */ static async update(id, tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the update data for debugging\n            console.log(\"TenantsService.update - Updating tenant:\", id, \"with data:\", tenantData);\n            // Filter out fields that don't exist in the RENT_tenants table\n            const { security_deposit, payment_history, late_fees_owed, late_status, last_payment_date, rent_cadence, ...filteredData } = tenantData;\n            // Include monthly_rent in the tenant update since it exists in the RENT_tenants table\n            if (tenantData.monthly_rent !== undefined) {\n                filteredData.monthly_rent = tenantData.monthly_rent;\n            }\n            console.log(\"TenantsService.update - Filtered data:\", filteredData);\n            // Update the tenant\n            const { data: updatedTenantData, error: tenantError } = await supabase.from(\"RENT_tenants\").update(filteredData).eq(\"id\", id).select(\"*\").single();\n            if (tenantError) {\n                console.error(\"TenantsService.update - Supabase error:\", tenantError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(tenantError));\n            }\n            // If monthly_rent was updated, also update the corresponding lease\n            if (tenantData.monthly_rent !== undefined && tenantData.monthly_rent !== null) {\n                try {\n                    // Find the active lease for this tenant\n                    const { data: leases, error: leaseError } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", id).eq(\"status\", \"active\").order(\"created_at\", {\n                        ascending: false\n                    }).limit(1);\n                    if (!leaseError && leases && leases.length > 0) {\n                        const activeLease = leases[0];\n                        console.log(\"TenantsService.update - Updating lease rent:\", activeLease.id, \"to:\", tenantData.monthly_rent);\n                        // Update the lease rent\n                        const { error: leaseUpdateError } = await supabase.from(\"RENT_leases\").update({\n                            rent: tenantData.monthly_rent\n                        }).eq(\"id\", activeLease.id);\n                        if (leaseUpdateError) {\n                            console.warn(\"TenantsService.update - Failed to update lease rent:\", leaseUpdateError);\n                        } else {\n                            console.log(\"TenantsService.update - Successfully updated lease rent\");\n                        }\n                    }\n                } catch (leaseUpdateError) {\n                    console.warn(\"TenantsService.update - Error updating lease rent:\", leaseUpdateError);\n                }\n            }\n            // Fetch the updated tenant with leases\n            const { data: updatedTenant, error: fetchError } = await supabase.from(\"RENT_tenants\").select(\"\\n          *,\\n          leases:RENT_leases(*)\\n        \").eq(\"id\", id).single();\n            if (fetchError) {\n                console.error(\"TenantsService.update - Error fetching updated tenant:\", fetchError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(fetchError));\n            }\n            return (0, client_1.createApiResponse)(updatedTenant);\n        } catch (error) {\n            console.error(\"TenantsService.update - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Delete a tenant\n     */ static async delete(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { error } = await supabase.from(\"RENT_tenants\").delete().eq(\"id\", id);\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(true);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get paginated tenants\n     */ static async getPaginated() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, filters = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const offset = (page - 1) * limit;\n            let query = supabase.from(\"RENT_tenants\").select(\"*\", {\n                count: \"exact\"\n            }).order(\"created_at\", {\n                ascending: false\n            }).range(offset, offset + limit - 1);\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error, count } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)({\n                data: tenantsWithRelations,\n                total: count || 0,\n                page,\n                limit,\n                hasMore: offset + limit < (count || 0)\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Search tenants\n     */ static async search(searchTerm) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").or(\"first_name.ilike.%\".concat(searchTerm, \"%,last_name.ilike.%\").concat(searchTerm, \"%,email.ilike.%\").concat(searchTerm, \"%\")).order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get active tenants\n     */ static async getActive() {\n        return this.getAll({\n            is_active: true\n        });\n    }\n    /**\n     * Get late tenants\n     */ static async getLate() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").neq(\"late_status\", \"on_time\").order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get tenants by property\n     */ static async getByProperty(propertyId) {\n        return this.getAll({\n            property_id: propertyId\n        });\n    }\n    /**\n     * Record a payment for a tenant\n     */ static async recordPayment(tenantId, paymentData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, get the current tenant with property information\n            const { data: currentTenant, error: getError } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", tenantId).single();\n            if (getError) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(getError));\n            }\n            if (!currentTenant) {\n                return (0, client_1.createApiResponse)(null, \"Tenant not found\");\n            }\n            // Fetch property data separately\n            let property = null;\n            if (currentTenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", currentTenant.property_id).single();\n                property = propData;\n            }\n            // TODO: Implement payment recording logic when database schema is updated\n            // For now, just return the tenant as-is\n            return (0, client_1.createApiResponse)(currentTenant);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get late tenants with detailed information using existing database structure\n     */ static async getLateTenants() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"is_active\", true) // Only check active tenants\n            .order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // TODO: Implement late tenant logic when database schema is updated\n            // For now, return empty array\n            return (0, client_1.createApiResponse)([]);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount due for a tenant using new pay period logic\n     */ static calculateTotalDue(tenant) {\n        if (!tenant.properties) {\n            // TODO: Implement total due calculation when database schema is updated\n            return 0;\n        }\n        const latePaymentInfo = this.calculateTotalLatePayments(tenant, tenant.properties);\n        return latePaymentInfo.totalDue;\n    }\n    /**\n     * Calculate days late based on last payment date\n     */ static calculateDaysLate(lastPaymentDate) {\n        if (!lastPaymentDate) return 0;\n        const lastPayment = new Date(lastPaymentDate);\n        const today = new Date();\n        const diffTime = Math.abs(today.getTime() - lastPayment.getTime());\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        return diffDays;\n    }\n    /**\n     * Calculate late periods based on days late and rent cadence\n     */ static calculateLatePeriods(tenant, daysLate) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return Math.ceil(daysLate / 7);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return Math.ceil(daysLate / 14);\n            case \"monthly\":\n            default:\n                return Math.ceil(daysLate / 30);\n        }\n    }\n    /**\n     * Calculate late fees based on late periods and rent cadence\n     */ static calculateLateFees(tenant, latePeriods) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        let lateFeePerPeriod = 0;\n        switch(normalizedCadence){\n            case \"weekly\":\n                lateFeePerPeriod = 10;\n                break;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                lateFeePerPeriod = 20;\n                break;\n            case \"monthly\":\n            default:\n                lateFeePerPeriod = 50;\n                break;\n        }\n        return latePeriods * lateFeePerPeriod;\n    }\n    /**\n     * Calculate total due including late fees\n     */ static calculateTotalDueWithLateFees(tenant, lateFees) {\n        const baseRent = tenant.leases && tenant.leases.length > 0 ? tenant.leases[0].rent : 0; // TODO: Implement base rent calculation when database schema is updated\n        return baseRent + lateFees;\n    }\n    /**\n     * Calculate what a tenant actually owes using the currently_paid_up_date\n     * This is the new improved calculation system\n     */ static calculateTenantOwedAmount(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            // TODO: Implement calculation when database schema is updated\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent) {\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        // TODO: Implement full calculation when database schema is updated\n        return {\n            totalOwed: 0,\n            totalLateFees: 0,\n            missedPeriods: 0,\n            missedPayments: []\n        };\n    }\n    /**\n     * Calculate total days late for a tenant\n     */ static calculateTotalDaysLate(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            return 0;\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent_cadence) {\n            return 0;\n        }\n        const rentCadence = activeLease.rent_cadence;\n        // TODO: Implement full calculation when database schema is updated\n        // For now, return 0 since we don't have access to payment history\n        return 0;\n    }\n    /**\n     * Get the late fee amount for a specific rent cadence\n     */ static getLateFeeAmount(cadence) {\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return 10;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return 20;\n            case \"monthly\":\n            default:\n                return 45;\n        }\n    }\n    /**\n     * Extract rent cadence from property notes\n     */ static extractRentCadence(notes) {\n        if (!notes) return \"monthly\";\n        const cadenceMatch = notes.match(/Rent cadence:\\s*(\\w+)/i);\n        return cadenceMatch ? cadenceMatch[1] : \"monthly\";\n    }\n    /**\n     * Calculate the number of days between two dates\n     */ static daysBetween(date1, date2) {\n        const d1 = new Date(date1);\n        const d2 = new Date(date2);\n        const diffTime = Math.abs(d2.getTime() - d1.getTime());\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n    /**\n     * Get the expected payment date for a specific pay period\n     */ static getExpectedPaymentDate(leaseStartDate, payPeriodIndex, cadence) {\n        const startDate = new Date(leaseStartDate);\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 7 * 24 * 60 * 60 * 1000);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 14 * 24 * 60 * 60 * 1000);\n            case \"monthly\":\n            default:\n                const result = new Date(startDate);\n                result.setMonth(result.getMonth() + payPeriodIndex);\n                return result;\n        }\n    }\n    /**\n     * Get the last N expected payment dates for a tenant\n     */ static getLastExpectedPaymentDates(leaseStartDate, cadence) {\n        let count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n        const dates = [];\n        const today = new Date();\n        // Find the most recent expected payment date\n        let currentPeriod = 0;\n        let currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        while(currentDate <= today && currentPeriod < count * 2){\n            currentPeriod++;\n            currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        }\n        // Get the last N periods\n        for(let i = Math.max(0, currentPeriod - count); i < currentPeriod; i++){\n            dates.push(this.getExpectedPaymentDate(leaseStartDate, i, cadence));\n        }\n        return dates;\n    }\n    /**\n     * Calculate late fees for a specific pay period\n     */ static calculateLateFeesForPeriod(expectedDate, paymentHistory, cadence, rentAmount) {\n        const lateFeeAmount = this.getLateFeeAmount(cadence);\n        // Find payments for this period (within 5 days of expected date)\n        const periodStart = new Date(expectedDate);\n        periodStart.setDate(periodStart.getDate() - 2); // Allow 2 days early\n        const periodEnd = new Date(expectedDate);\n        periodEnd.setDate(periodEnd.getDate() + 5); // 5 days grace period\n        const periodPayments = paymentHistory.filter((payment)=>{\n            const paymentDate = new Date(payment.date);\n            return paymentDate >= periodStart && paymentDate <= periodEnd && payment.status === \"completed\";\n        });\n        const totalPaid = periodPayments.reduce((sum, payment)=>sum + payment.amount, 0);\n        const outstanding = Math.max(0, rentAmount - totalPaid);\n        // Check if payment is late (after grace period)\n        const lastPaymentDate = periodPayments.length > 0 ? new Date(Math.max(...periodPayments.map((p)=>new Date(p.date).getTime()))) : null;\n        if (!lastPaymentDate || lastPaymentDate > periodEnd) {\n            // Payment is late\n            const daysLate = lastPaymentDate ? this.daysBetween(periodEnd, lastPaymentDate) : this.daysBetween(periodEnd, new Date());\n            return {\n                isLate: true,\n                daysLate: Math.max(0, daysLate),\n                lateFees: outstanding > 0 ? lateFeeAmount : 0,\n                totalPaid,\n                outstanding\n            };\n        }\n        return {\n            isLate: false,\n            daysLate: 0,\n            lateFees: 0,\n            totalPaid,\n            outstanding\n        };\n    }\n    /**\n     * Calculate total late payments for a tenant\n     */ static calculateTotalLatePayments(tenant, property) {\n        // TODO: Implement late payment calculation when database schema is updated\n        return {\n            totalDue: 0,\n            totalLateFees: 0,\n            latePeriods: 0\n        };\n    }\n    /**\n     * Check if a tenant is late on payments\n     */ static isTenantLate(tenant, property) {\n        // TODO: Implement late payment check when database schema is updated\n        return false;\n    }\n    /**\n     * Create tenant by property address\n     */ static async createByPropertyAddress(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, find the property by address\n            const { data: property, error: propertyError } = await supabase.from(\"RENT_properties\").select(\"id, monthly_rent\").ilike(\"address\", \"%\".concat(tenantData.property_address, \"%\")).single();\n            if (propertyError) {\n                return (0, client_1.createApiResponse)(null, \"Property not found with address: \".concat(tenantData.property_address));\n            }\n            // Create tenant with property_id\n            const { property_address, ...tenantCreateData } = tenantData;\n            const tenantDataWithProperty = {\n                ...tenantCreateData,\n                property_id: property.id,\n                monthly_rent: tenantData.monthly_rent || property.monthly_rent\n            };\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                tenantDataWithProperty\n            ]).select(\"*, RENT_properties(name, address)\").single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Bulk create tenants by property address\n     */ static async bulkCreateByPropertyAddress(tenantsData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const created = [];\n            const errors = [];\n            for (const tenantData of tenantsData){\n                try {\n                    const result = await this.createByPropertyAddress(tenantData);\n                    if (result.success && result.data) {\n                        created.push(result.data);\n                    } else {\n                        errors.push(\"Failed to create tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(result.error));\n                    }\n                } catch (error) {\n                    errors.push(\"Error creating tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(error));\n                }\n            }\n            return (0, client_1.createApiResponse)({\n                created,\n                errors\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount owed by a tenant\n     */ static calculateTotalAmountOwed(tenant) {\n        // TODO: Implement total amount calculation when database schema is updated\n        // For now, return 0 since these fields don't exist in the current schema\n        return 0;\n    }\n    /**\n     * Get the rent amount for a tenant\n     */ static getRentAmount(tenant) {\n        // TODO: Implement rent amount calculation when database schema is updated\n        // For now, return 0 since monthly_rent field doesn't exist in the current schema\n        return 0;\n    }\n    /**\n     * Calculate days since last payment\n     */ static calculateDaysSinceLastPayment(tenant) {\n        // TODO: Implement days since last payment calculation when database schema is updated\n        return 0;\n    }\n    /**\n     * Calculate days since lease start\n     */ static calculateDaysSinceLeaseStart(tenant) {\n        // TODO: Implement days since lease start calculation when database schema is updated\n        return 0;\n    }\n}\nexports.TenantsService = TenantsService;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9hcGkvZGlzdC9zZXJ2aWNlcy90ZW5hbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFXO0FBQ3BDLE1BQU1GO0lBQ0Y7O0tBRUMsR0FDRCxhQUFhRyxPQUFPQyxPQUFPLEVBQUU7UUFDekIsSUFBSTtZQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHSixTQUFTSyxpQkFBaUI7WUFDL0MsSUFBSUMsUUFBUUYsU0FDUEcsSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBTTtZQUM1QyxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFdBQVcsRUFBRTtnQkFDdEJMLFFBQVFBLE1BQU1NLEVBQUUsQ0FBQyxlQUFlVCxRQUFRUSxXQUFXO1lBQ3ZEO1lBQ0EsSUFBSVIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTVSxTQUFTLE1BQUtDLFdBQVc7Z0JBQ2xDUixRQUFRQSxNQUFNTSxFQUFFLENBQUMsYUFBYVQsUUFBUVUsU0FBUztZQUNuRDtZQUNBLElBQUlWLG9CQUFBQSw4QkFBQUEsUUFBU1ksV0FBVyxFQUFFO2dCQUN0QlQsUUFBUUEsTUFBTU0sRUFBRSxDQUFDLGVBQWVULFFBQVFZLFdBQVc7WUFDdkQ7WUFDQSxNQUFNLEVBQUVDLE1BQU1DLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVo7WUFDdkMsSUFBSVksT0FBTztnQkFDUCxPQUFPLENBQUMsR0FBR2xCLFNBQVNtQixpQkFBaUIsRUFBRSxNQUFNLENBQUMsR0FBR25CLFNBQVNvQixtQkFBbUIsRUFBRUY7WUFDbkY7WUFDQSx5Q0FBeUM7WUFDekMsTUFBTUcsdUJBQXVCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ04sUUFB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Li4vLi4vcGFja2FnZXMvYXBpL2Rpc3Qvc2VydmljZXMvdGVuYW50cy5qcz9iMzY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZW5hbnRzU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4uL2NsaWVudFwiKTtcbmNsYXNzIFRlbmFudHNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRlbmFudHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0QWxsKGZpbHRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8ucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwcm9wZXJ0eV9pZCcsIGZpbHRlcnMucHJvcGVydHlfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmlzX2FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfYWN0aXZlJywgZmlsdGVycy5pc19hY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmxhdGVfc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnbGF0ZV9zdGF0dXMnLCBmaWx0ZXJzLmxhdGVfc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MsIG5vdGVzLCBtb250aGx5X3JlbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdGVuYW50IGJ5IElEXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEJ5SWQoaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB0ZW5hbnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRlbmFudC5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgYWRkcmVzcywgbm90ZXMsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGxlYXNlc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ3RlbmFudF9pZCcsIHRlbmFudC5pZClcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRXaXRoUmVsYXRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRlbmFudCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh0ZW5hbnRXaXRoUmVsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHRlbmFudERhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgLy8gTG9nIHRoZSBkYXRhIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBJbnB1dCBkYXRhOicsIHRlbmFudERhdGEpO1xuICAgICAgICAgICAgLy8gT25seSBzZW5kIHRoZSBjb2x1bW5zIHRoYXQgYWN0dWFsbHkgZXhpc3QgaW4gdGhlIFJFTlRfdGVuYW50cyB0YWJsZVxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eV9pZDogdGVuYW50RGF0YS5wcm9wZXJ0eV9pZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiB0ZW5hbnREYXRhLmZpcnN0X25hbWUsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiB0ZW5hbnREYXRhLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogdGVuYW50RGF0YS5lbWFpbCxcbiAgICAgICAgICAgICAgICBwaG9uZTogdGVuYW50RGF0YS5waG9uZSxcbiAgICAgICAgICAgICAgICBtb250aGx5X3JlbnQ6IHRlbmFudERhdGEubW9udGhseV9yZW50LFxuICAgICAgICAgICAgICAgIGxlYXNlX3N0YXJ0X2RhdGU6IHRlbmFudERhdGEubGVhc2Vfc3RhcnRfZGF0ZSxcbiAgICAgICAgICAgICAgICBsZWFzZV9lbmRfZGF0ZTogdGVuYW50RGF0YS5sZWFzZV9lbmRfZGF0ZSxcbiAgICAgICAgICAgICAgICBub3RlczogdGVuYW50RGF0YS5ub3Rlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBJbnNlcnQgZGF0YSAoZmlsdGVyZWQpOicsIGluc2VydERhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuaW5zZXJ0KFtpbnNlcnREYXRhXSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gU3VjY2VzcywgY3JlYXRlZCB0ZW5hbnQ6JywgZGF0YSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gc2ltcGxlIHJlc3BvbnNlIHdpdGhvdXQgYWRkaXRpb25hbCBkYXRhIGZvciBub3dcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgdGVuYW50XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHVwZGF0ZShpZCwgdGVuYW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIHVwZGF0ZSBkYXRhIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBVcGRhdGluZyB0ZW5hbnQ6JywgaWQsICd3aXRoIGRhdGE6JywgdGVuYW50RGF0YSk7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGZpZWxkcyB0aGF0IGRvbid0IGV4aXN0IGluIHRoZSBSRU5UX3RlbmFudHMgdGFibGVcbiAgICAgICAgICAgIGNvbnN0IHsgc2VjdXJpdHlfZGVwb3NpdCwgcGF5bWVudF9oaXN0b3J5LCBsYXRlX2ZlZXNfb3dlZCwgbGF0ZV9zdGF0dXMsIGxhc3RfcGF5bWVudF9kYXRlLCByZW50X2NhZGVuY2UsIC4uLmZpbHRlcmVkRGF0YSB9ID0gdGVuYW50RGF0YTtcbiAgICAgICAgICAgIC8vIEluY2x1ZGUgbW9udGhseV9yZW50IGluIHRoZSB0ZW5hbnQgdXBkYXRlIHNpbmNlIGl0IGV4aXN0cyBpbiB0aGUgUkVOVF90ZW5hbnRzIHRhYmxlXG4gICAgICAgICAgICBpZiAodGVuYW50RGF0YS5tb250aGx5X3JlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGF0YS5tb250aGx5X3JlbnQgPSB0ZW5hbnREYXRhLm1vbnRobHlfcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBGaWx0ZXJlZCBkYXRhOicsIGZpbHRlcmVkRGF0YSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRlbmFudFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkVGVuYW50RGF0YSwgZXJyb3I6IHRlbmFudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZmlsdGVyZWREYXRhKVxuICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAodGVuYW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBTdXBhYmFzZSBlcnJvcjonLCB0ZW5hbnRFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKHRlbmFudEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtb250aGx5X3JlbnQgd2FzIHVwZGF0ZWQsIGFsc28gdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIGxlYXNlXG4gICAgICAgICAgICBpZiAodGVuYW50RGF0YS5tb250aGx5X3JlbnQgIT09IHVuZGVmaW5lZCAmJiB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGFjdGl2ZSBsZWFzZSBmb3IgdGhpcyB0ZW5hbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXMsIGVycm9yOiBsZWFzZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCBpZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5saW1pdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFzZUVycm9yICYmIGxlYXNlcyAmJiBsZWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlTGVhc2UgPSBsZWFzZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gVXBkYXRpbmcgbGVhc2UgcmVudDonLCBhY3RpdmVMZWFzZS5pZCwgJ3RvOicsIHRlbmFudERhdGEubW9udGhseV9yZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVhc2UgcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogbGVhc2VVcGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGUoeyByZW50OiB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBhY3RpdmVMZWFzZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVhc2VVcGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gRmFpbGVkIHRvIHVwZGF0ZSBsZWFzZSByZW50OicsIGxlYXNlVXBkYXRlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGxlYXNlIHJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAobGVhc2VVcGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIEVycm9yIHVwZGF0aW5nIGxlYXNlIHJlbnQ6JywgbGVhc2VVcGRhdGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHVwZGF0ZWQgdGVuYW50IHdpdGggbGVhc2VzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRUZW5hbnQsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoYFxyXG4gICAgICAgICAgKixcclxuICAgICAgICAgIGxlYXNlczpSRU5UX2xlYXNlcygqKVxyXG4gICAgICAgIGApXG4gICAgICAgICAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIGlmIChmZXRjaEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gRXJyb3IgZmV0Y2hpbmcgdXBkYXRlZCB0ZW5hbnQ6JywgZmV0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGZldGNoRXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHVwZGF0ZWRUZW5hbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZGVsZXRlKGlkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAgICAgLmVxKCdpZCcsIGlkKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcGFnaW5hdGVkIHRlbmFudHNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0UGFnaW5hdGVkKHBhZ2UgPSAxLCBsaW1pdCA9IDEwLCBmaWx0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChwYWdlIC0gMSkgKiBsaW1pdDtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicsIHsgY291bnQ6ICdleGFjdCcgfSlcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgICAgICAucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCAtIDEpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgncHJvcGVydHlfaWQnLCBmaWx0ZXJzLnByb3BlcnR5X2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJzPy5pc19hY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2lzX2FjdGl2ZScsIGZpbHRlcnMuaXNfYWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJzPy5sYXRlX3N0YXR1cykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2xhdGVfc3RhdHVzJywgZmlsdGVycy5sYXRlX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudHMsIGVycm9yLCBjb3VudCB9ID0gYXdhaXQgcXVlcnk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnRpZXMgYW5kIGxlYXNlcyBzZXBhcmF0ZWx5XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRzV2l0aFJlbGF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKHRlbmFudHMubWFwKGFzeW5jICh0ZW5hbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRlbmFudC5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHByb3BEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgYWRkcmVzcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoJ2lkJywgdGVuYW50LnByb3BlcnR5X2lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBsZWFzZXNcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IGxlYXNlc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX2xlYXNlcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgICAgICAuZXEoJ3RlbmFudF9pZCcsIHRlbmFudC5pZClcbiAgICAgICAgICAgICAgICAgICAgLm9yZGVyKCdsZWFzZV9zdGFydF9kYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRlbmFudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGxlYXNlczogbGVhc2VzRGF0YSB8fCBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh7XG4gICAgICAgICAgICAgICAgZGF0YTogdGVuYW50c1dpdGhSZWxhdGlvbnMsXG4gICAgICAgICAgICAgICAgdG90YWw6IGNvdW50IHx8IDAsXG4gICAgICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICBoYXNNb3JlOiBvZmZzZXQgKyBsaW1pdCA8IChjb3VudCB8fCAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdGVuYW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBzZWFyY2goc2VhcmNoVGVybSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudHMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5vcihgZmlyc3RfbmFtZS5pbGlrZS4lJHtzZWFyY2hUZXJtfSUsbGFzdF9uYW1lLmlsaWtlLiUke3NlYXJjaFRlcm19JSxlbWFpbC5pbGlrZS4lJHtzZWFyY2hUZXJtfSVgKVxuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydGllcyBhbmQgbGVhc2VzIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudHNXaXRoUmVsYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwodGVuYW50cy5tYXAoYXN5bmMgKHRlbmFudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGxlYXNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogbGVhc2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGVuYW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGVhc2VzOiBsZWFzZXNEYXRhIHx8IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHRlbmFudHNXaXRoUmVsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY3RpdmUgdGVuYW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbCh7IGlzX2FjdGl2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxhdGUgdGVuYW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRMYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudHMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5uZXEoJ2xhdGVfc3RhdHVzJywgJ29uX3RpbWUnKVxuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydGllcyBhbmQgbGVhc2VzIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudHNXaXRoUmVsYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwodGVuYW50cy5tYXAoYXN5bmMgKHRlbmFudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGxlYXNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogbGVhc2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGVuYW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGVhc2VzOiBsZWFzZXNEYXRhIHx8IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHRlbmFudHNXaXRoUmVsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0ZW5hbnRzIGJ5IHByb3BlcnR5XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEJ5UHJvcGVydHkocHJvcGVydHlJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoeyBwcm9wZXJ0eV9pZDogcHJvcGVydHlJZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkIGEgcGF5bWVudCBmb3IgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVjb3JkUGF5bWVudCh0ZW5hbnRJZCwgcGF5bWVudERhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIGdldCB0aGUgY3VycmVudCB0ZW5hbnQgd2l0aCBwcm9wZXJ0eSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjdXJyZW50VGVuYW50LCBlcnJvcjogZ2V0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudElkKVxuICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIGlmIChnZXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShnZXRFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50VGVuYW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgJ1RlbmFudCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5IGRhdGEgc2VwYXJhdGVseVxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzLCBub3RlcywgbW9udGhseV9yZW50JylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIGN1cnJlbnRUZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHBheW1lbnQgcmVjb3JkaW5nIGxvZ2ljIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIEZvciBub3csIGp1c3QgcmV0dXJuIHRoZSB0ZW5hbnQgYXMtaXNcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKGN1cnJlbnRUZW5hbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxhdGUgdGVuYW50cyB3aXRoIGRldGFpbGVkIGluZm9ybWF0aW9uIHVzaW5nIGV4aXN0aW5nIGRhdGFiYXNlIHN0cnVjdHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRMYXRlVGVuYW50cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB0ZW5hbnRzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpIC8vIE9ubHkgY2hlY2sgYWN0aXZlIHRlbmFudHNcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBsYXRlIHRlbmFudCBsb2dpYyB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBhbW91bnQgZHVlIGZvciBhIHRlbmFudCB1c2luZyBuZXcgcGF5IHBlcmlvZCBsb2dpY1xuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbER1ZSh0ZW5hbnQpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQucHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHRvdGFsIGR1ZSBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXRlUGF5bWVudEluZm8gPSB0aGlzLmNhbGN1bGF0ZVRvdGFsTGF0ZVBheW1lbnRzKHRlbmFudCwgdGVuYW50LnByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gbGF0ZVBheW1lbnRJbmZvLnRvdGFsRHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZGF5cyBsYXRlIGJhc2VkIG9uIGxhc3QgcGF5bWVudCBkYXRlXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZURheXNMYXRlKGxhc3RQYXltZW50RGF0ZSkge1xuICAgICAgICBpZiAoIWxhc3RQYXltZW50RGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCBsYXN0UGF5bWVudCA9IG5ldyBEYXRlKGxhc3RQYXltZW50RGF0ZSk7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgZGlmZlRpbWUgPSBNYXRoLmFicyh0b2RheS5nZXRUaW1lKCkgLSBsYXN0UGF5bWVudC5nZXRUaW1lKCkpO1xuICAgICAgICBjb25zdCBkaWZmRGF5cyA9IE1hdGguY2VpbChkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgICAgIHJldHVybiBkaWZmRGF5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxhdGUgcGVyaW9kcyBiYXNlZCBvbiBkYXlzIGxhdGUgYW5kIHJlbnQgY2FkZW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVMYXRlUGVyaW9kcyh0ZW5hbnQsIGRheXNMYXRlKSB7XG4gICAgICAgIGlmICghdGVuYW50LmxlYXNlcyB8fCB0ZW5hbnQubGVhc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCBjYWRlbmNlID0gdGVuYW50LmxlYXNlc1swXS5yZW50X2NhZGVuY2UgfHwgJ21vbnRobHknO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChkYXlzTGF0ZSAvIDcpO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChkYXlzTGF0ZSAvIDE0KTtcbiAgICAgICAgICAgIGNhc2UgJ21vbnRobHknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGRheXNMYXRlIC8gMzApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsYXRlIGZlZXMgYmFzZWQgb24gbGF0ZSBwZXJpb2RzIGFuZCByZW50IGNhZGVuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlTGF0ZUZlZXModGVuYW50LCBsYXRlUGVyaW9kcykge1xuICAgICAgICBpZiAoIXRlbmFudC5sZWFzZXMgfHwgdGVuYW50LmxlYXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgY2FkZW5jZSA9IHRlbmFudC5sZWFzZXNbMF0ucmVudF9jYWRlbmNlIHx8ICdtb250aGx5JztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENhZGVuY2UgPSBjYWRlbmNlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBsZXQgbGF0ZUZlZVBlclBlcmlvZCA9IDA7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgbGF0ZUZlZVBlclBlcmlvZCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgbGF0ZUZlZVBlclBlcmlvZCA9IDIwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxhdGVGZWVQZXJQZXJpb2QgPSA1MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZVBlcmlvZHMgKiBsYXRlRmVlUGVyUGVyaW9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG90YWwgZHVlIGluY2x1ZGluZyBsYXRlIGZlZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVG90YWxEdWVXaXRoTGF0ZUZlZXModGVuYW50LCBsYXRlRmVlcykge1xuICAgICAgICBjb25zdCBiYXNlUmVudCA9IHRlbmFudC5sZWFzZXMgJiYgdGVuYW50LmxlYXNlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHRlbmFudC5sZWFzZXNbMF0ucmVudFxuICAgICAgICAgICAgOiAwOyAvLyBUT0RPOiBJbXBsZW1lbnQgYmFzZSByZW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIGJhc2VSZW50ICsgbGF0ZUZlZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB3aGF0IGEgdGVuYW50IGFjdHVhbGx5IG93ZXMgdXNpbmcgdGhlIGN1cnJlbnRseV9wYWlkX3VwX2RhdGVcbiAgICAgKiBUaGlzIGlzIHRoZSBuZXcgaW1wcm92ZWQgY2FsY3VsYXRpb24gc3lzdGVtXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZVRlbmFudE93ZWRBbW91bnQodGVuYW50KSB7XG4gICAgICAgIGlmICghdGVuYW50LmxlYXNlcyB8fCB0ZW5hbnQubGVhc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG90YWxPd2VkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsTGF0ZUZlZXM6IDAsXG4gICAgICAgICAgICAgICAgbWlzc2VkUGVyaW9kczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQYXltZW50czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlTGVhc2UgPSB0ZW5hbnQubGVhc2VzWzBdO1xuICAgICAgICBpZiAoIWFjdGl2ZUxlYXNlLmxlYXNlX3N0YXJ0X2RhdGUgfHwgIWFjdGl2ZUxlYXNlLnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG90YWxPd2VkOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsTGF0ZUZlZXM6IDAsXG4gICAgICAgICAgICAgICAgbWlzc2VkUGVyaW9kczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQYXltZW50czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGZ1bGwgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxPd2VkOiAwLFxuICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgIG1pc3NlZFBlcmlvZHM6IDAsXG4gICAgICAgICAgICBtaXNzZWRQYXltZW50czogW11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvdGFsIGRheXMgbGF0ZSBmb3IgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVG90YWxEYXlzTGF0ZSh0ZW5hbnQpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQubGVhc2VzIHx8IHRlbmFudC5sZWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVMZWFzZSA9IHRlbmFudC5sZWFzZXNbMF07XG4gICAgICAgIGlmICghYWN0aXZlTGVhc2UubGVhc2Vfc3RhcnRfZGF0ZSB8fCAhYWN0aXZlTGVhc2UucmVudF9jYWRlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW50Q2FkZW5jZSA9IGFjdGl2ZUxlYXNlLnJlbnRfY2FkZW5jZTtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGZ1bGwgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gMCBzaW5jZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byBwYXltZW50IGhpc3RvcnlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF0ZSBmZWUgYW1vdW50IGZvciBhIHNwZWNpZmljIHJlbnQgY2FkZW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRMYXRlRmVlQW1vdW50KGNhZGVuY2UpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENhZGVuY2UgPSBjYWRlbmNlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRDYWRlbmNlKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrbHknOlxuICAgICAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICAgIGNhc2UgJ2JpLXdlZWtseSc6XG4gICAgICAgICAgICBjYXNlICdiaXdlZWtseSc6XG4gICAgICAgICAgICBjYXNlICdiaV93ZWVrbHknOlxuICAgICAgICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgICAgIGNhc2UgJ21vbnRobHknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gNDU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCByZW50IGNhZGVuY2UgZnJvbSBwcm9wZXJ0eSBub3Rlc1xuICAgICAqL1xuICAgIHN0YXRpYyBleHRyYWN0UmVudENhZGVuY2Uobm90ZXMpIHtcbiAgICAgICAgaWYgKCFub3RlcylcbiAgICAgICAgICAgIHJldHVybiAnbW9udGhseSc7XG4gICAgICAgIGNvbnN0IGNhZGVuY2VNYXRjaCA9IG5vdGVzLm1hdGNoKC9SZW50IGNhZGVuY2U6XFxzKihcXHcrKS9pKTtcbiAgICAgICAgcmV0dXJuIGNhZGVuY2VNYXRjaCA/IGNhZGVuY2VNYXRjaFsxXSA6ICdtb250aGx5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHR3byBkYXRlc1xuICAgICAqL1xuICAgIHN0YXRpYyBkYXlzQmV0d2VlbihkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgY29uc3QgZDEgPSBuZXcgRGF0ZShkYXRlMSk7XG4gICAgICAgIGNvbnN0IGQyID0gbmV3IERhdGUoZGF0ZTIpO1xuICAgICAgICBjb25zdCBkaWZmVGltZSA9IE1hdGguYWJzKGQyLmdldFRpbWUoKSAtIGQxLmdldFRpbWUoKSk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoZGlmZlRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV4cGVjdGVkIHBheW1lbnQgZGF0ZSBmb3IgYSBzcGVjaWZpYyBwYXkgcGVyaW9kXG4gICAgICovXG4gICAgc3RhdGljIGdldEV4cGVjdGVkUGF5bWVudERhdGUobGVhc2VTdGFydERhdGUsIHBheVBlcmlvZEluZGV4LCBjYWRlbmNlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGxlYXNlU3RhcnREYXRlKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENhZGVuY2UgPSBjYWRlbmNlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRDYWRlbmNlKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrbHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShzdGFydERhdGUuZ2V0VGltZSgpICsgKHBheVBlcmlvZEluZGV4ICogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGNhc2UgJ2JpLXdlZWtseSc6XG4gICAgICAgICAgICBjYXNlICdiaXdlZWtseSc6XG4gICAgICAgICAgICBjYXNlICdiaV93ZWVrbHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShzdGFydERhdGUuZ2V0VGltZSgpICsgKHBheVBlcmlvZEluZGV4ICogMTQgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICBjYXNlICdtb250aGx5JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0TW9udGgocmVzdWx0LmdldE1vbnRoKCkgKyBwYXlQZXJpb2RJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgTiBleHBlY3RlZCBwYXltZW50IGRhdGVzIGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRMYXN0RXhwZWN0ZWRQYXltZW50RGF0ZXMobGVhc2VTdGFydERhdGUsIGNhZGVuY2UsIGNvdW50ID0gMTIpIHtcbiAgICAgICAgY29uc3QgZGF0ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBGaW5kIHRoZSBtb3N0IHJlY2VudCBleHBlY3RlZCBwYXltZW50IGRhdGVcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSAwO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSB0aGlzLmdldEV4cGVjdGVkUGF5bWVudERhdGUobGVhc2VTdGFydERhdGUsIGN1cnJlbnRQZXJpb2QsIGNhZGVuY2UpO1xuICAgICAgICB3aGlsZSAoY3VycmVudERhdGUgPD0gdG9kYXkgJiYgY3VycmVudFBlcmlvZCA8IGNvdW50ICogMikge1xuICAgICAgICAgICAgY3VycmVudFBlcmlvZCsrO1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSB0aGlzLmdldEV4cGVjdGVkUGF5bWVudERhdGUobGVhc2VTdGFydERhdGUsIGN1cnJlbnRQZXJpb2QsIGNhZGVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgbGFzdCBOIHBlcmlvZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGN1cnJlbnRQZXJpb2QgLSBjb3VudCk7IGkgPCBjdXJyZW50UGVyaW9kOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGVzLnB1c2godGhpcy5nZXRFeHBlY3RlZFBheW1lbnREYXRlKGxlYXNlU3RhcnREYXRlLCBpLCBjYWRlbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGF0ZSBmZWVzIGZvciBhIHNwZWNpZmljIHBheSBwZXJpb2RcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlTGF0ZUZlZXNGb3JQZXJpb2QoZXhwZWN0ZWREYXRlLCBwYXltZW50SGlzdG9yeSwgY2FkZW5jZSwgcmVudEFtb3VudCkge1xuICAgICAgICBjb25zdCBsYXRlRmVlQW1vdW50ID0gdGhpcy5nZXRMYXRlRmVlQW1vdW50KGNhZGVuY2UpO1xuICAgICAgICAvLyBGaW5kIHBheW1lbnRzIGZvciB0aGlzIHBlcmlvZCAod2l0aGluIDUgZGF5cyBvZiBleHBlY3RlZCBkYXRlKVxuICAgICAgICBjb25zdCBwZXJpb2RTdGFydCA9IG5ldyBEYXRlKGV4cGVjdGVkRGF0ZSk7XG4gICAgICAgIHBlcmlvZFN0YXJ0LnNldERhdGUocGVyaW9kU3RhcnQuZ2V0RGF0ZSgpIC0gMik7IC8vIEFsbG93IDIgZGF5cyBlYXJseVxuICAgICAgICBjb25zdCBwZXJpb2RFbmQgPSBuZXcgRGF0ZShleHBlY3RlZERhdGUpO1xuICAgICAgICBwZXJpb2RFbmQuc2V0RGF0ZShwZXJpb2RFbmQuZ2V0RGF0ZSgpICsgNSk7IC8vIDUgZGF5cyBncmFjZSBwZXJpb2RcbiAgICAgICAgY29uc3QgcGVyaW9kUGF5bWVudHMgPSBwYXltZW50SGlzdG9yeS5maWx0ZXIocGF5bWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXltZW50RGF0ZSA9IG5ldyBEYXRlKHBheW1lbnQuZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bWVudERhdGUgPj0gcGVyaW9kU3RhcnQgJiYgcGF5bWVudERhdGUgPD0gcGVyaW9kRW5kICYmIHBheW1lbnQuc3RhdHVzID09PSAnY29tcGxldGVkJztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvdGFsUGFpZCA9IHBlcmlvZFBheW1lbnRzLnJlZHVjZSgoc3VtLCBwYXltZW50KSA9PiBzdW0gKyBwYXltZW50LmFtb3VudCwgMCk7XG4gICAgICAgIGNvbnN0IG91dHN0YW5kaW5nID0gTWF0aC5tYXgoMCwgcmVudEFtb3VudCAtIHRvdGFsUGFpZCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHBheW1lbnQgaXMgbGF0ZSAoYWZ0ZXIgZ3JhY2UgcGVyaW9kKVxuICAgICAgICBjb25zdCBsYXN0UGF5bWVudERhdGUgPSBwZXJpb2RQYXltZW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IG5ldyBEYXRlKE1hdGgubWF4KC4uLnBlcmlvZFBheW1lbnRzLm1hcChwID0+IG5ldyBEYXRlKHAuZGF0ZSkuZ2V0VGltZSgpKSkpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghbGFzdFBheW1lbnREYXRlIHx8IGxhc3RQYXltZW50RGF0ZSA+IHBlcmlvZEVuZCkge1xuICAgICAgICAgICAgLy8gUGF5bWVudCBpcyBsYXRlXG4gICAgICAgICAgICBjb25zdCBkYXlzTGF0ZSA9IGxhc3RQYXltZW50RGF0ZVxuICAgICAgICAgICAgICAgID8gdGhpcy5kYXlzQmV0d2VlbihwZXJpb2RFbmQsIGxhc3RQYXltZW50RGF0ZSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuZGF5c0JldHdlZW4ocGVyaW9kRW5kLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNMYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRheXNMYXRlOiBNYXRoLm1heCgwLCBkYXlzTGF0ZSksXG4gICAgICAgICAgICAgICAgbGF0ZUZlZXM6IG91dHN0YW5kaW5nID4gMCA/IGxhdGVGZWVBbW91bnQgOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsUGFpZCxcbiAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNMYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGRheXNMYXRlOiAwLFxuICAgICAgICAgICAgbGF0ZUZlZXM6IDAsXG4gICAgICAgICAgICB0b3RhbFBhaWQsXG4gICAgICAgICAgICBvdXRzdGFuZGluZ1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG90YWwgbGF0ZSBwYXltZW50cyBmb3IgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVG90YWxMYXRlUGF5bWVudHModGVuYW50LCBwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgbGF0ZSBwYXltZW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsRHVlOiAwLFxuICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgIGxhdGVQZXJpb2RzOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGVuYW50IGlzIGxhdGUgb24gcGF5bWVudHNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUZW5hbnRMYXRlKHRlbmFudCwgcHJvcGVydHkpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGxhdGUgcGF5bWVudCBjaGVjayB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRlbmFudCBieSBwcm9wZXJ0eSBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZUJ5UHJvcGVydHlBZGRyZXNzKHRlbmFudERhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIHByb3BlcnR5IGJ5IGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcGVydHksIGVycm9yOiBwcm9wZXJ0eUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBtb250aGx5X3JlbnQnKVxuICAgICAgICAgICAgICAgIC5pbGlrZSgnYWRkcmVzcycsIGAlJHt0ZW5hbnREYXRhLnByb3BlcnR5X2FkZHJlc3N9JWApXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCBgUHJvcGVydHkgbm90IGZvdW5kIHdpdGggYWRkcmVzczogJHt0ZW5hbnREYXRhLnByb3BlcnR5X2FkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGVuYW50IHdpdGggcHJvcGVydHlfaWRcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcGVydHlfYWRkcmVzcywgLi4udGVuYW50Q3JlYXRlRGF0YSB9ID0gdGVuYW50RGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudERhdGFXaXRoUHJvcGVydHkgPSB7XG4gICAgICAgICAgICAgICAgLi4udGVuYW50Q3JlYXRlRGF0YSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eV9pZDogcHJvcGVydHkuaWQsXG4gICAgICAgICAgICAgICAgbW9udGhseV9yZW50OiB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCB8fCBwcm9wZXJ0eS5tb250aGx5X3JlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5pbnNlcnQoW3RlbmFudERhdGFXaXRoUHJvcGVydHldKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyosIFJFTlRfcHJvcGVydGllcyhuYW1lLCBhZGRyZXNzKScpXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1bGsgY3JlYXRlIHRlbmFudHMgYnkgcHJvcGVydHkgYWRkcmVzc1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBidWxrQ3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3ModGVuYW50c0RhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRlbmFudERhdGEgb2YgdGVuYW50c0RhdGEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUJ5UHJvcGVydHlBZGRyZXNzKHRlbmFudERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQucHVzaChyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChgRmFpbGVkIHRvIGNyZWF0ZSB0ZW5hbnQgJHt0ZW5hbnREYXRhLmZpcnN0X25hbWV9ICR7dGVuYW50RGF0YS5sYXN0X25hbWV9OiAke3Jlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYEVycm9yIGNyZWF0aW5nIHRlbmFudCAke3RlbmFudERhdGEuZmlyc3RfbmFtZX0gJHt0ZW5hbnREYXRhLmxhc3RfbmFtZX06ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkoeyBjcmVhdGVkLCBlcnJvcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG90YWwgYW1vdW50IG93ZWQgYnkgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVG90YWxBbW91bnRPd2VkKHRlbmFudCkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgdG90YWwgYW1vdW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIDAgc2luY2UgdGhlc2UgZmllbGRzIGRvbid0IGV4aXN0IGluIHRoZSBjdXJyZW50IHNjaGVtYVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZW50IGFtb3VudCBmb3IgYSB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVudEFtb3VudCh0ZW5hbnQpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHJlbnQgYW1vdW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIDAgc2luY2UgbW9udGhseV9yZW50IGZpZWxkIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGN1cnJlbnQgc2NoZW1hXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZGF5cyBzaW5jZSBsYXN0IHBheW1lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlRGF5c1NpbmNlTGFzdFBheW1lbnQodGVuYW50KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBkYXlzIHNpbmNlIGxhc3QgcGF5bWVudCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZGF5cyBzaW5jZSBsZWFzZSBzdGFydFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVEYXlzU2luY2VMZWFzZVN0YXJ0KHRlbmFudCkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZGF5cyBzaW5jZSBsZWFzZSBzdGFydCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuVGVuYW50c1NlcnZpY2UgPSBUZW5hbnRzU2VydmljZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRlbmFudHNTZXJ2aWNlIiwiY2xpZW50XzEiLCJyZXF1aXJlIiwiZ2V0QWxsIiwiZmlsdGVycyIsInN1cGFiYXNlIiwiZ2V0U3VwYWJhc2VDbGllbnQiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsInByb3BlcnR5X2lkIiwiZXEiLCJpc19hY3RpdmUiLCJ1bmRlZmluZWQiLCJsYXRlX3N0YXR1cyIsImRhdGEiLCJ0ZW5hbnRzIiwiZXJyb3IiLCJjcmVhdGVBcGlSZXNwb25zZSIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJ0ZW5hbnRzV2l0aFJlbGF0aW9ucyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJ0ZW5hbnQiLCJwcm9wZXJ0eSIsInByb3BEYXRhIiwic2luZ2xlIiwibGVhc2VzRGF0YSIsImlkIiwicHJvcGVydGllcyIsImxlYXNlcyIsImdldEJ5SWQiLCJ0ZW5hbnRXaXRoUmVsYXRpb25zIiwiY3JlYXRlIiwidGVuYW50RGF0YSIsImNvbnNvbGUiLCJsb2ciLCJpbnNlcnREYXRhIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImVtYWlsIiwicGhvbmUiLCJtb250aGx5X3JlbnQiLCJsZWFzZV9zdGFydF9kYXRlIiwibGVhc2VfZW5kX2RhdGUiLCJub3RlcyIsImluc2VydCIsInVwZGF0ZSIsInNlY3VyaXR5X2RlcG9zaXQiLCJwYXltZW50X2hpc3RvcnkiLCJsYXRlX2ZlZXNfb3dlZCIsImxhc3RfcGF5bWVudF9kYXRlIiwicmVudF9jYWRlbmNlIiwiZmlsdGVyZWREYXRhIiwidXBkYXRlZFRlbmFudERhdGEiLCJ0ZW5hbnRFcnJvciIsImxlYXNlRXJyb3IiLCJsaW1pdCIsImxlbmd0aCIsImFjdGl2ZUxlYXNlIiwibGVhc2VVcGRhdGVFcnJvciIsInJlbnQiLCJ3YXJuIiwidXBkYXRlZFRlbmFudCIsImZldGNoRXJyb3IiLCJkZWxldGUiLCJnZXRQYWdpbmF0ZWQiLCJwYWdlIiwib2Zmc2V0IiwiY291bnQiLCJyYW5nZSIsInRvdGFsIiwiaGFzTW9yZSIsInNlYXJjaCIsInNlYXJjaFRlcm0iLCJvciIsImdldEFjdGl2ZSIsImdldExhdGUiLCJuZXEiLCJnZXRCeVByb3BlcnR5IiwicHJvcGVydHlJZCIsInJlY29yZFBheW1lbnQiLCJ0ZW5hbnRJZCIsInBheW1lbnREYXRhIiwiY3VycmVudFRlbmFudCIsImdldEVycm9yIiwiZ2V0TGF0ZVRlbmFudHMiLCJjYWxjdWxhdGVUb3RhbER1ZSIsImxhdGVQYXltZW50SW5mbyIsImNhbGN1bGF0ZVRvdGFsTGF0ZVBheW1lbnRzIiwidG90YWxEdWUiLCJjYWxjdWxhdGVEYXlzTGF0ZSIsImxhc3RQYXltZW50RGF0ZSIsImxhc3RQYXltZW50IiwiRGF0ZSIsInRvZGF5IiwiZGlmZlRpbWUiLCJNYXRoIiwiYWJzIiwiZ2V0VGltZSIsImRpZmZEYXlzIiwiY2VpbCIsImNhbGN1bGF0ZUxhdGVQZXJpb2RzIiwiZGF5c0xhdGUiLCJjYWRlbmNlIiwibm9ybWFsaXplZENhZGVuY2UiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJjYWxjdWxhdGVMYXRlRmVlcyIsImxhdGVQZXJpb2RzIiwibGF0ZUZlZVBlclBlcmlvZCIsImNhbGN1bGF0ZVRvdGFsRHVlV2l0aExhdGVGZWVzIiwibGF0ZUZlZXMiLCJiYXNlUmVudCIsImNhbGN1bGF0ZVRlbmFudE93ZWRBbW91bnQiLCJ0b3RhbE93ZWQiLCJ0b3RhbExhdGVGZWVzIiwibWlzc2VkUGVyaW9kcyIsIm1pc3NlZFBheW1lbnRzIiwiY2FsY3VsYXRlVG90YWxEYXlzTGF0ZSIsInJlbnRDYWRlbmNlIiwiZ2V0TGF0ZUZlZUFtb3VudCIsImV4dHJhY3RSZW50Q2FkZW5jZSIsImNhZGVuY2VNYXRjaCIsIm1hdGNoIiwiZGF5c0JldHdlZW4iLCJkYXRlMSIsImRhdGUyIiwiZDEiLCJkMiIsImdldEV4cGVjdGVkUGF5bWVudERhdGUiLCJsZWFzZVN0YXJ0RGF0ZSIsInBheVBlcmlvZEluZGV4Iiwic3RhcnREYXRlIiwicmVzdWx0Iiwic2V0TW9udGgiLCJnZXRNb250aCIsImdldExhc3RFeHBlY3RlZFBheW1lbnREYXRlcyIsImRhdGVzIiwiY3VycmVudFBlcmlvZCIsImN1cnJlbnREYXRlIiwiaSIsIm1heCIsInB1c2giLCJjYWxjdWxhdGVMYXRlRmVlc0ZvclBlcmlvZCIsImV4cGVjdGVkRGF0ZSIsInBheW1lbnRIaXN0b3J5IiwicmVudEFtb3VudCIsImxhdGVGZWVBbW91bnQiLCJwZXJpb2RTdGFydCIsInNldERhdGUiLCJnZXREYXRlIiwicGVyaW9kRW5kIiwicGVyaW9kUGF5bWVudHMiLCJmaWx0ZXIiLCJwYXltZW50IiwicGF5bWVudERhdGUiLCJkYXRlIiwic3RhdHVzIiwidG90YWxQYWlkIiwicmVkdWNlIiwic3VtIiwiYW1vdW50Iiwib3V0c3RhbmRpbmciLCJwIiwiaXNMYXRlIiwiaXNUZW5hbnRMYXRlIiwiY3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3MiLCJwcm9wZXJ0eUVycm9yIiwiaWxpa2UiLCJwcm9wZXJ0eV9hZGRyZXNzIiwidGVuYW50Q3JlYXRlRGF0YSIsInRlbmFudERhdGFXaXRoUHJvcGVydHkiLCJidWxrQ3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3MiLCJ0ZW5hbnRzRGF0YSIsImNyZWF0ZWQiLCJlcnJvcnMiLCJzdWNjZXNzIiwiY2FsY3VsYXRlVG90YWxBbW91bnRPd2VkIiwiZ2V0UmVudEFtb3VudCIsImNhbGN1bGF0ZURheXNTaW5jZUxhc3RQYXltZW50IiwiY2FsY3VsYXRlRGF5c1NpbmNlTGVhc2VTdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/api/dist/services/tenants.js\n"));

/***/ })

});