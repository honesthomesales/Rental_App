"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tenants/edit/page",{

/***/ "(app-pages-browser)/../../packages/api/dist/services/tenants.js":
/*!***************************************************!*\
  !*** ../../packages/api/dist/services/tenants.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TenantsService = void 0;\nconst client_1 = __webpack_require__(/*! ../client */ \"(app-pages-browser)/../../packages/api/dist/client.js\");\nclass TenantsService {\n    /**\n     * Get all tenants with optional filtering\n     */ static async getAll(filters) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            let query = supabase.from(\"RENT_tenants\").select(\"*\").order(\"created_at\", {\n                ascending: false\n            });\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get a tenant by ID\n     */ static async getById(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenant, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", id).single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch property\n            let property = null;\n            if (tenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                property = propData;\n            }\n            // Fetch leases\n            const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                ascending: false\n            });\n            const tenantWithRelations = {\n                ...tenant,\n                properties: property,\n                leases: leasesData || []\n            };\n            return (0, client_1.createApiResponse)(tenantWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Create a new tenant\n     */ static async create(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the data being sent\n            console.log(\"TenantsService.create - Input data:\", tenantData);\n            // Only send the columns that actually exist in the RENT_tenants table\n            const insertData = {\n                property_id: tenantData.property_id,\n                first_name: tenantData.first_name,\n                last_name: tenantData.last_name,\n                email: tenantData.email,\n                phone: tenantData.phone,\n                // monthly_rent: (tenantData as any).monthly_rent, // Temporarily removed due to schema mismatch\n                lease_start_date: tenantData.lease_start_date,\n                lease_end_date: tenantData.lease_end_date,\n                notes: tenantData.notes\n            };\n            console.log(\"TenantsService.create - Insert data (filtered):\", insertData);\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                insertData\n            ]).select(\"*\").single();\n            if (error) {\n                console.error(\"TenantsService.create - Supabase error:\", error);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            console.log(\"TenantsService.create - Success, created tenant:\", data);\n            // Return simple response without additional data for now\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            console.error(\"TenantsService.create - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Update an existing tenant\n     */ static async update(id, tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the update data for debugging\n            console.log(\"TenantsService.update - Updating tenant:\", id, \"with data:\", tenantData);\n            // Filter out fields that don't exist in the RENT_tenants table\n            const { monthly_rent, security_deposit, payment_history, late_fees_owed, late_status, last_payment_date, rent_cadence, ...filteredData } = tenantData;\n            console.log(\"TenantsService.update - Filtered data:\", filteredData);\n            // Update the tenant\n            const { data: updatedTenantData, error: tenantError } = await supabase.from(\"RENT_tenants\").update(filteredData).eq(\"id\", id).select(\"*\").single();\n            if (tenantError) {\n                console.error(\"TenantsService.update - Supabase error:\", tenantError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(tenantError));\n            }\n            // If monthly_rent was updated, also update the corresponding lease\n            if (tenantData.monthly_rent !== undefined && tenantData.monthly_rent !== null) {\n                try {\n                    // Find the active lease for this tenant\n                    const { data: leases, error: leaseError } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", id).eq(\"status\", \"active\").order(\"created_at\", {\n                        ascending: false\n                    }).limit(1);\n                    if (!leaseError && leases && leases.length > 0) {\n                        const activeLease = leases[0];\n                        console.log(\"TenantsService.update - Updating lease rent:\", activeLease.id, \"to:\", tenantData.monthly_rent);\n                        // Update the lease rent\n                        const { error: leaseUpdateError } = await supabase.from(\"RENT_leases\").update({\n                            rent: tenantData.monthly_rent\n                        }).eq(\"id\", activeLease.id);\n                        if (leaseUpdateError) {\n                            console.warn(\"TenantsService.update - Failed to update lease rent:\", leaseUpdateError);\n                        } else {\n                            console.log(\"TenantsService.update - Successfully updated lease rent\");\n                        }\n                    }\n                } catch (leaseUpdateError) {\n                    console.warn(\"TenantsService.update - Error updating lease rent:\", leaseUpdateError);\n                }\n            }\n            // Fetch the updated tenant with leases\n            const { data: updatedTenant, error: fetchError } = await supabase.from(\"RENT_tenants\").select(\"\\n          *,\\n          leases:RENT_leases(*)\\n        \").eq(\"id\", id).single();\n            if (fetchError) {\n                console.error(\"TenantsService.update - Error fetching updated tenant:\", fetchError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(fetchError));\n            }\n            return (0, client_1.createApiResponse)(updatedTenant);\n        } catch (error) {\n            console.error(\"TenantsService.update - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Delete a tenant\n     */ static async delete(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { error } = await supabase.from(\"RENT_tenants\").delete().eq(\"id\", id);\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(true);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get paginated tenants\n     */ static async getPaginated() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, filters = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const offset = (page - 1) * limit;\n            let query = supabase.from(\"RENT_tenants\").select(\"*\", {\n                count: \"exact\"\n            }).order(\"created_at\", {\n                ascending: false\n            }).range(offset, offset + limit - 1);\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error, count } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)({\n                data: tenantsWithRelations,\n                total: count || 0,\n                page,\n                limit,\n                hasMore: offset + limit < (count || 0)\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Search tenants\n     */ static async search(searchTerm) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").or(\"first_name.ilike.%\".concat(searchTerm, \"%,last_name.ilike.%\").concat(searchTerm, \"%,email.ilike.%\").concat(searchTerm, \"%\")).order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get active tenants\n     */ static async getActive() {\n        return this.getAll({\n            is_active: true\n        });\n    }\n    /**\n     * Get late tenants\n     */ static async getLate() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").neq(\"late_status\", \"on_time\").order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get tenants by property\n     */ static async getByProperty(propertyId) {\n        return this.getAll({\n            property_id: propertyId\n        });\n    }\n    /**\n     * Record a payment for a tenant\n     */ static async recordPayment(tenantId, paymentData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, get the current tenant with property information\n            const { data: currentTenant, error: getError } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", tenantId).single();\n            if (getError) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(getError));\n            }\n            if (!currentTenant) {\n                return (0, client_1.createApiResponse)(null, \"Tenant not found\");\n            }\n            // Fetch property data separately\n            let property = null;\n            if (currentTenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", currentTenant.property_id).single();\n                property = propData;\n            }\n            // TODO: Implement payment recording logic when database schema is updated\n            // For now, just return the tenant as-is\n            return (0, client_1.createApiResponse)(currentTenant);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get late tenants with detailed information using existing database structure\n     */ static async getLateTenants() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"is_active\", true) // Only check active tenants\n            .order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // TODO: Implement late tenant logic when database schema is updated\n            // For now, return empty array\n            return (0, client_1.createApiResponse)([]);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount due for a tenant using new pay period logic\n     */ static calculateTotalDue(tenant) {\n        if (!tenant.properties) {\n            // TODO: Implement total due calculation when database schema is updated\n            return 0;\n        }\n        const latePaymentInfo = this.calculateTotalLatePayments(tenant, tenant.properties);\n        return latePaymentInfo.totalDue;\n    }\n    /**\n     * Calculate days late based on last payment date\n     */ static calculateDaysLate(lastPaymentDate) {\n        if (!lastPaymentDate) return 0;\n        const lastPayment = new Date(lastPaymentDate);\n        const today = new Date();\n        const diffTime = Math.abs(today.getTime() - lastPayment.getTime());\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        return diffDays;\n    }\n    /**\n     * Calculate late periods based on days late and rent cadence\n     */ static calculateLatePeriods(tenant, daysLate) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return Math.ceil(daysLate / 7);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return Math.ceil(daysLate / 14);\n            case \"monthly\":\n            default:\n                return Math.ceil(daysLate / 30);\n        }\n    }\n    /**\n     * Calculate late fees based on late periods and rent cadence\n     */ static calculateLateFees(tenant, latePeriods) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        let lateFeePerPeriod = 0;\n        switch(normalizedCadence){\n            case \"weekly\":\n                lateFeePerPeriod = 10;\n                break;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                lateFeePerPeriod = 20;\n                break;\n            case \"monthly\":\n            default:\n                lateFeePerPeriod = 50;\n                break;\n        }\n        return latePeriods * lateFeePerPeriod;\n    }\n    /**\n     * Calculate total due including late fees\n     */ static calculateTotalDueWithLateFees(tenant, lateFees) {\n        const baseRent = tenant.leases && tenant.leases.length > 0 ? tenant.leases[0].rent : 0; // TODO: Implement base rent calculation when database schema is updated\n        return baseRent + lateFees;\n    }\n    /**\n     * Calculate what a tenant actually owes using the currently_paid_up_date\n     * This is the new improved calculation system\n     */ static calculateTenantOwedAmount(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            // TODO: Implement calculation when database schema is updated\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent) {\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        // TODO: Implement full calculation when database schema is updated\n        return {\n            totalOwed: 0,\n            totalLateFees: 0,\n            missedPeriods: 0,\n            missedPayments: []\n        };\n    }\n    /**\n     * Calculate total days late for a tenant\n     */ static calculateTotalDaysLate(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            return 0;\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent_cadence) {\n            return 0;\n        }\n        const rentCadence = activeLease.rent_cadence;\n        // TODO: Implement full calculation when database schema is updated\n        // For now, return 0 since we don't have access to payment history\n        return 0;\n    }\n    /**\n     * Get the late fee amount for a specific rent cadence\n     */ static getLateFeeAmount(cadence) {\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return 10;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return 20;\n            case \"monthly\":\n            default:\n                return 45;\n        }\n    }\n    /**\n     * Extract rent cadence from property notes\n     */ static extractRentCadence(notes) {\n        if (!notes) return \"monthly\";\n        const cadenceMatch = notes.match(/Rent cadence:\\s*(\\w+)/i);\n        return cadenceMatch ? cadenceMatch[1] : \"monthly\";\n    }\n    /**\n     * Calculate the number of days between two dates\n     */ static daysBetween(date1, date2) {\n        const d1 = new Date(date1);\n        const d2 = new Date(date2);\n        const diffTime = Math.abs(d2.getTime() - d1.getTime());\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n    /**\n     * Get the expected payment date for a specific pay period\n     */ static getExpectedPaymentDate(leaseStartDate, payPeriodIndex, cadence) {\n        const startDate = new Date(leaseStartDate);\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 7 * 24 * 60 * 60 * 1000);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 14 * 24 * 60 * 60 * 1000);\n            case \"monthly\":\n            default:\n                const result = new Date(startDate);\n                result.setMonth(result.getMonth() + payPeriodIndex);\n                return result;\n        }\n    }\n    /**\n     * Get the last N expected payment dates for a tenant\n     */ static getLastExpectedPaymentDates(leaseStartDate, cadence) {\n        let count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n        const dates = [];\n        const today = new Date();\n        // Find the most recent expected payment date\n        let currentPeriod = 0;\n        let currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        while(currentDate <= today && currentPeriod < count * 2){\n            currentPeriod++;\n            currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        }\n        // Get the last N periods\n        for(let i = Math.max(0, currentPeriod - count); i < currentPeriod; i++){\n            dates.push(this.getExpectedPaymentDate(leaseStartDate, i, cadence));\n        }\n        return dates;\n    }\n    /**\n     * Calculate late fees for a specific pay period\n     */ static calculateLateFeesForPeriod(expectedDate, paymentHistory, cadence, rentAmount) {\n        const lateFeeAmount = this.getLateFeeAmount(cadence);\n        // Find payments for this period (within 5 days of expected date)\n        const periodStart = new Date(expectedDate);\n        periodStart.setDate(periodStart.getDate() - 2); // Allow 2 days early\n        const periodEnd = new Date(expectedDate);\n        periodEnd.setDate(periodEnd.getDate() + 5); // 5 days grace period\n        const periodPayments = paymentHistory.filter((payment)=>{\n            const paymentDate = new Date(payment.date);\n            return paymentDate >= periodStart && paymentDate <= periodEnd && payment.status === \"completed\";\n        });\n        const totalPaid = periodPayments.reduce((sum, payment)=>sum + payment.amount, 0);\n        const outstanding = Math.max(0, rentAmount - totalPaid);\n        // Check if payment is late (after grace period)\n        const lastPaymentDate = periodPayments.length > 0 ? new Date(Math.max(...periodPayments.map((p)=>new Date(p.date).getTime()))) : null;\n        if (!lastPaymentDate || lastPaymentDate > periodEnd) {\n            // Payment is late\n            const daysLate = lastPaymentDate ? this.daysBetween(periodEnd, lastPaymentDate) : this.daysBetween(periodEnd, new Date());\n            return {\n                isLate: true,\n                daysLate: Math.max(0, daysLate),\n                lateFees: outstanding > 0 ? lateFeeAmount : 0,\n                totalPaid,\n                outstanding\n            };\n        }\n        return {\n            isLate: false,\n            daysLate: 0,\n            lateFees: 0,\n            totalPaid,\n            outstanding\n        };\n    }\n    /**\n     * Calculate total late payments for a tenant\n     */ static calculateTotalLatePayments(tenant, property) {\n        // TODO: Implement late payment calculation when database schema is updated\n        return {\n            totalDue: 0,\n            totalLateFees: 0,\n            latePeriods: 0\n        };\n    }\n    /**\n     * Check if a tenant is late on payments\n     */ static isTenantLate(tenant, property) {\n        // TODO: Implement late payment check when database schema is updated\n        return false;\n    }\n    /**\n     * Create tenant by property address\n     */ static async createByPropertyAddress(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, find the property by address\n            const { data: property, error: propertyError } = await supabase.from(\"RENT_properties\").select(\"id, monthly_rent\").ilike(\"address\", \"%\".concat(tenantData.property_address, \"%\")).single();\n            if (propertyError) {\n                return (0, client_1.createApiResponse)(null, \"Property not found with address: \".concat(tenantData.property_address));\n            }\n            // Create tenant with property_id\n            const { property_address, ...tenantCreateData } = tenantData;\n            const tenantDataWithProperty = {\n                ...tenantCreateData,\n                property_id: property.id,\n                monthly_rent: tenantData.monthly_rent || property.monthly_rent\n            };\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                tenantDataWithProperty\n            ]).select(\"*, RENT_properties(name, address)\").single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Bulk create tenants by property address\n     */ static async bulkCreateByPropertyAddress(tenantsData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const created = [];\n            const errors = [];\n            for (const tenantData of tenantsData){\n                try {\n                    const result = await this.createByPropertyAddress(tenantData);\n                    if (result.success && result.data) {\n                        created.push(result.data);\n                    } else {\n                        errors.push(\"Failed to create tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(result.error));\n                    }\n                } catch (error) {\n                    errors.push(\"Error creating tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(error));\n                }\n            }\n            return (0, client_1.createApiResponse)({\n                created,\n                errors\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount owed by a tenant\n     */ static calculateTotalAmountOwed(tenant) {\n        // TODO: Implement total amount calculation when database schema is updated\n        // For now, return 0 since these fields don't exist in the current schema\n        return 0;\n    }\n    /**\n     * Get the rent amount for a tenant\n     */ static getRentAmount(tenant) {\n        // TODO: Implement rent amount calculation when database schema is updated\n        // For now, return 0 since monthly_rent field doesn't exist in the current schema\n        return 0;\n    }\n    /**\n     * Calculate days since last payment\n     */ static calculateDaysSinceLastPayment(tenant) {\n        // TODO: Implement days since last payment calculation when database schema is updated\n        return 0;\n    }\n    /**\n     * Calculate days since lease start\n     */ static calculateDaysSinceLeaseStart(tenant) {\n        // TODO: Implement days since lease start calculation when database schema is updated\n        return 0;\n    }\n}\nexports.TenantsService = TenantsService;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9hcGkvZGlzdC9zZXJ2aWNlcy90ZW5hbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFXO0FBQ3BDLE1BQU1GO0lBQ0Y7O0tBRUMsR0FDRCxhQUFhRyxPQUFPQyxPQUFPLEVBQUU7UUFDekIsSUFBSTtZQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHSixTQUFTSyxpQkFBaUI7WUFDL0MsSUFBSUMsUUFBUUYsU0FDUEcsSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBTTtZQUM1QyxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFdBQVcsRUFBRTtnQkFDdEJMLFFBQVFBLE1BQU1NLEVBQUUsQ0FBQyxlQUFlVCxRQUFRUSxXQUFXO1lBQ3ZEO1lBQ0EsSUFBSVIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTVSxTQUFTLE1BQUtDLFdBQVc7Z0JBQ2xDUixRQUFRQSxNQUFNTSxFQUFFLENBQUMsYUFBYVQsUUFBUVUsU0FBUztZQUNuRDtZQUNBLElBQUlWLG9CQUFBQSw4QkFBQUEsUUFBU1ksV0FBVyxFQUFFO2dCQUN0QlQsUUFBUUEsTUFBTU0sRUFBRSxDQUFDLGVBQWVULFFBQVFZLFdBQVc7WUFDdkQ7WUFDQSxNQUFNLEVBQUVDLE1BQU1DLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVo7WUFDdkMsSUFBSVksT0FBTztnQkFDUCxPQUFPLENBQUMsR0FBR2xCLFNBQVNtQixpQkFBaUIsRUFBRSxNQUFNLENBQUMsR0FBR25CLFNBQVNvQixtQkFBbUIsRUFBRUY7WUFDbkY7WUFDQSx5Q0FBeUM7WUFDekMsTUFBTUcsdUJBQXVCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ04sUUFB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QU94SCxJQUFJO29CQUM1QixPQUNLO3dCQUNEa0ssT0FBT2pDLElBQUksQ0FBQywyQkFBb0Q3RyxPQUF6QkEsV0FBV0ksVUFBVSxFQUFDLEtBQTRCZ0csT0FBekJwRyxXQUFXSyxTQUFTLEVBQUMsTUFBaUIsT0FBYitGLE9BQU90SCxLQUFLO29CQUN6RztnQkFDSixFQUNBLE9BQU9BLE9BQU87b0JBQ1ZnSyxPQUFPakMsSUFBSSxDQUFDLHlCQUFrRDdHLE9BQXpCQSxXQUFXSSxVQUFVLEVBQUMsS0FBNEJ0QixPQUF6QmtCLFdBQVdLLFNBQVMsRUFBQyxNQUFVLE9BQU52QjtnQkFDM0Y7WUFDSjtZQUNBLE9BQU8sQ0FBQyxHQUFHbEIsU0FBU21CLGlCQUFpQixFQUFFO2dCQUFFOEo7Z0JBQVNDO1lBQU87UUFDN0QsRUFDQSxPQUFPaEssT0FBTztZQUNWLE9BQU8sQ0FBQyxHQUFHbEIsU0FBU21CLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxHQUFHbkIsU0FBU29CLG1CQUFtQixFQUFFRjtRQUNuRjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxPQUFPa0sseUJBQXlCM0osTUFBTSxFQUFFO1FBQ3BDLDJFQUEyRTtRQUMzRSx5RUFBeUU7UUFDekUsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxPQUFPNEosY0FBYzVKLE1BQU0sRUFBRTtRQUN6QiwwRUFBMEU7UUFDMUUsaUZBQWlGO1FBQ2pGLE9BQU87SUFDWDtJQUNBOztLQUVDLEdBQ0QsT0FBTzZKLDhCQUE4QjdKLE1BQU0sRUFBRTtRQUN6QyxzRkFBc0Y7UUFDdEYsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxPQUFPOEosNkJBQTZCOUosTUFBTSxFQUFFO1FBQ3hDLHFGQUFxRjtRQUNyRixPQUFPO0lBQ1g7QUFDSjtBQUNBNUIsc0JBQXNCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9hcGkvZGlzdC9zZXJ2aWNlcy90ZW5hbnRzLmpzP2IzNjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRlbmFudHNTZXJ2aWNlID0gdm9pZCAwO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vY2xpZW50XCIpO1xuY2xhc3MgVGVuYW50c1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGVuYW50cyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRBbGwoZmlsdGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJzPy5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3Byb3BlcnR5X2lkJywgZmlsdGVycy5wcm9wZXJ0eV9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8uaXNfYWN0aXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdpc19hY3RpdmUnLCBmaWx0ZXJzLmlzX2FjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8ubGF0ZV9zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdsYXRlX3N0YXR1cycsIGZpbHRlcnMubGF0ZV9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB0ZW5hbnRzLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnRpZXMgYW5kIGxlYXNlcyBzZXBhcmF0ZWx5XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRzV2l0aFJlbGF0aW9ucyA9IGF3YWl0IFByb21pc2UuYWxsKHRlbmFudHMubWFwKGFzeW5jICh0ZW5hbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRlbmFudC5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHByb3BEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgYWRkcmVzcywgbm90ZXMsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoJ2lkJywgdGVuYW50LnByb3BlcnR5X2lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBsZWFzZXNcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IGxlYXNlc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX2xlYXNlcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgICAgICAuZXEoJ3RlbmFudF9pZCcsIHRlbmFudC5pZClcbiAgICAgICAgICAgICAgICAgICAgLm9yZGVyKCdsZWFzZV9zdGFydF9kYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRlbmFudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGxlYXNlczogbGVhc2VzRGF0YSB8fCBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh0ZW5hbnRzV2l0aFJlbGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0ZW5hbnQgYnkgSURcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0QnlJZChpZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzLCBub3RlcywgbW9udGhseV9yZW50JylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBsZWFzZXNcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogbGVhc2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50LmlkKVxuICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudFdpdGhSZWxhdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGVuYW50LFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGxlYXNlczogbGVhc2VzRGF0YSB8fCBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHRlbmFudFdpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUodGVuYW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIGRhdGEgYmVpbmcgc2VudFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLmNyZWF0ZSAtIElucHV0IGRhdGE6JywgdGVuYW50RGF0YSk7XG4gICAgICAgICAgICAvLyBPbmx5IHNlbmQgdGhlIGNvbHVtbnMgdGhhdCBhY3R1YWxseSBleGlzdCBpbiB0aGUgUkVOVF90ZW5hbnRzIHRhYmxlXG4gICAgICAgICAgICBjb25zdCBpbnNlcnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5X2lkOiB0ZW5hbnREYXRhLnByb3BlcnR5X2lkLFxuICAgICAgICAgICAgICAgIGZpcnN0X25hbWU6IHRlbmFudERhdGEuZmlyc3RfbmFtZSxcbiAgICAgICAgICAgICAgICBsYXN0X25hbWU6IHRlbmFudERhdGEubGFzdF9uYW1lLFxuICAgICAgICAgICAgICAgIGVtYWlsOiB0ZW5hbnREYXRhLmVtYWlsLFxuICAgICAgICAgICAgICAgIHBob25lOiB0ZW5hbnREYXRhLnBob25lLFxuICAgICAgICAgICAgICAgIC8vIG1vbnRobHlfcmVudDogKHRlbmFudERhdGEgYXMgYW55KS5tb250aGx5X3JlbnQsIC8vIFRlbXBvcmFyaWx5IHJlbW92ZWQgZHVlIHRvIHNjaGVtYSBtaXNtYXRjaFxuICAgICAgICAgICAgICAgIGxlYXNlX3N0YXJ0X2RhdGU6IHRlbmFudERhdGEubGVhc2Vfc3RhcnRfZGF0ZSxcbiAgICAgICAgICAgICAgICBsZWFzZV9lbmRfZGF0ZTogdGVuYW50RGF0YS5sZWFzZV9lbmRfZGF0ZSxcbiAgICAgICAgICAgICAgICBub3RlczogdGVuYW50RGF0YS5ub3Rlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBJbnNlcnQgZGF0YSAoZmlsdGVyZWQpOicsIGluc2VydERhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuaW5zZXJ0KFtpbnNlcnREYXRhXSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBTdXBhYmFzZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gU3VjY2VzcywgY3JlYXRlZCB0ZW5hbnQ6JywgZGF0YSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gc2ltcGxlIHJlc3BvbnNlIHdpdGhvdXQgYWRkaXRpb25hbCBkYXRhIGZvciBub3dcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgdGVuYW50XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHVwZGF0ZShpZCwgdGVuYW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIHVwZGF0ZSBkYXRhIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBVcGRhdGluZyB0ZW5hbnQ6JywgaWQsICd3aXRoIGRhdGE6JywgdGVuYW50RGF0YSk7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGZpZWxkcyB0aGF0IGRvbid0IGV4aXN0IGluIHRoZSBSRU5UX3RlbmFudHMgdGFibGVcbiAgICAgICAgICAgIGNvbnN0IHsgbW9udGhseV9yZW50LCAvLyBSZW1vdmUgdGhpcyBzaW5jZSBpdCdzIGNhdXNpbmcgdGhlIGVycm9yXG4gICAgICAgICAgICBzZWN1cml0eV9kZXBvc2l0LCBwYXltZW50X2hpc3RvcnksIGxhdGVfZmVlc19vd2VkLCBsYXRlX3N0YXR1cywgbGFzdF9wYXltZW50X2RhdGUsIHJlbnRfY2FkZW5jZSwgLi4uZmlsdGVyZWREYXRhIH0gPSB0ZW5hbnREYXRhO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIEZpbHRlcmVkIGRhdGE6JywgZmlsdGVyZWREYXRhKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGVuYW50XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRUZW5hbnREYXRhLCBlcnJvcjogdGVuYW50RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShmaWx0ZXJlZERhdGEpXG4gICAgICAgICAgICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgIGlmICh0ZW5hbnRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIFN1cGFiYXNlIGVycm9yOicsIHRlbmFudEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikodGVuYW50RXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG1vbnRobHlfcmVudCB3YXMgdXBkYXRlZCwgYWxzbyB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgbGVhc2VcbiAgICAgICAgICAgIGlmICh0ZW5hbnREYXRhLm1vbnRobHlfcmVudCAhPT0gdW5kZWZpbmVkICYmIHRlbmFudERhdGEubW9udGhseV9yZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYWN0aXZlIGxlYXNlIGZvciB0aGlzIHRlbmFudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IGxlYXNlcywgZXJyb3I6IGxlYXNlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXEoJ3RlbmFudF9pZCcsIGlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmxpbWl0KDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlYXNlRXJyb3IgJiYgbGVhc2VzICYmIGxlYXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVMZWFzZSA9IGxlYXNlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBVcGRhdGluZyBsZWFzZSByZW50OicsIGFjdGl2ZUxlYXNlLmlkLCAndG86JywgdGVuYW50RGF0YS5tb250aGx5X3JlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsZWFzZSByZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiBsZWFzZVVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX2xlYXNlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZSh7IHJlbnQ6IHRlbmFudERhdGEubW9udGhseV9yZW50IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIGFjdGl2ZUxlYXNlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWFzZVVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBGYWlsZWQgdG8gdXBkYXRlIGxlYXNlIHJlbnQ6JywgbGVhc2VVcGRhdGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgbGVhc2UgcmVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChsZWFzZVVwZGF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gRXJyb3IgdXBkYXRpbmcgbGVhc2UgcmVudDonLCBsZWFzZVVwZGF0ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgdXBkYXRlZCB0ZW5hbnQgd2l0aCBsZWFzZXNcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlZFRlbmFudCwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdChgXHJcbiAgICAgICAgICAqLFxyXG4gICAgICAgICAgbGVhc2VzOlJFTlRfbGVhc2VzKCopXHJcbiAgICAgICAgYClcbiAgICAgICAgICAgICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKGZldGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBFcnJvciBmZXRjaGluZyB1cGRhdGVkIHRlbmFudDonLCBmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZmV0Y2hFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodXBkYXRlZFRlbmFudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkZWxldGUoaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgICAgICAuZXEoJ2lkJywgaWQpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwYWdpbmF0ZWQgdGVuYW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRQYWdpbmF0ZWQocGFnZSA9IDEsIGxpbWl0ID0gMTAsIGZpbHRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIGxpbWl0O1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgIC5yYW5nZShvZmZzZXQsIG9mZnNldCArIGxpbWl0IC0gMSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8ucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwcm9wZXJ0eV9pZCcsIGZpbHRlcnMucHJvcGVydHlfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmlzX2FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfYWN0aXZlJywgZmlsdGVycy5pc19hY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmxhdGVfc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnbGF0ZV9zdGF0dXMnLCBmaWx0ZXJzLmxhdGVfc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBxdWVyeTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydGllcyBhbmQgbGVhc2VzIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudHNXaXRoUmVsYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwodGVuYW50cy5tYXAoYXN5bmMgKHRlbmFudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGxlYXNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogbGVhc2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGVuYW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGVhc2VzOiBsZWFzZXNEYXRhIHx8IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZW5hbnRzV2l0aFJlbGF0aW9ucyxcbiAgICAgICAgICAgICAgICB0b3RhbDogY291bnQgfHwgMCxcbiAgICAgICAgICAgICAgICBwYWdlLFxuICAgICAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgICAgIGhhc01vcmU6IG9mZnNldCArIGxpbWl0IDwgKGNvdW50IHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHNlYXJjaChzZWFyY2hUZXJtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLm9yKGBmaXJzdF9uYW1lLmlsaWtlLiUke3NlYXJjaFRlcm19JSxsYXN0X25hbWUuaWxpa2UuJSR7c2VhcmNoVGVybX0lLGVtYWlsLmlsaWtlLiUke3NlYXJjaFRlcm19JWApXG4gICAgICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjdGl2ZSB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKHsgaXNfYWN0aXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGF0ZSB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldExhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLm5lcSgnbGF0ZV9zdGF0dXMnLCAnb25fdGltZScpXG4gICAgICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRlbmFudHMgYnkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0QnlQcm9wZXJ0eShwcm9wZXJ0eUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbCh7IHByb3BlcnR5X2lkOiBwcm9wZXJ0eUlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgYSBwYXltZW50IGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZWNvcmRQYXltZW50KHRlbmFudElkLCBwYXltZW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZ2V0IHRoZSBjdXJyZW50IHRlbmFudCB3aXRoIHByb3BlcnR5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRUZW5hbnQsIGVycm9yOiBnZXRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ2lkJywgdGVuYW50SWQpXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKGdldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGdldEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRUZW5hbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAnVGVuYW50IG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHkgZGF0YSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHByb3BEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MsIG5vdGVzLCBtb250aGx5X3JlbnQnKVxuICAgICAgICAgICAgICAgICAgICAuZXEoJ2lkJywgY3VycmVudFRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcGF5bWVudCByZWNvcmRpbmcgbG9naWMgd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgLy8gRm9yIG5vdywganVzdCByZXR1cm4gdGhlIHRlbmFudCBhcy1pc1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkoY3VycmVudFRlbmFudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGF0ZSB0ZW5hbnRzIHdpdGggZGV0YWlsZWQgaW5mb3JtYXRpb24gdXNpbmcgZXhpc3RpbmcgZGF0YWJhc2Ugc3RydWN0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldExhdGVUZW5hbnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudHMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSkgLy8gT25seSBjaGVjayBhY3RpdmUgdGVuYW50c1xuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGxhdGUgdGVuYW50IGxvZ2ljIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIEZvciBub3csIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkoW10pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCBkdWUgZm9yIGEgdGVuYW50IHVzaW5nIG5ldyBwYXkgcGVyaW9kIGxvZ2ljXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZVRvdGFsRHVlKHRlbmFudCkge1xuICAgICAgICBpZiAoIXRlbmFudC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgdG90YWwgZHVlIGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVQYXltZW50SW5mbyA9IHRoaXMuY2FsY3VsYXRlVG90YWxMYXRlUGF5bWVudHModGVuYW50LCB0ZW5hbnQucHJvcGVydGllcyk7XG4gICAgICAgIHJldHVybiBsYXRlUGF5bWVudEluZm8udG90YWxEdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIGxhdGUgYmFzZWQgb24gbGFzdCBwYXltZW50IGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlRGF5c0xhdGUobGFzdFBheW1lbnREYXRlKSB7XG4gICAgICAgIGlmICghbGFzdFBheW1lbnREYXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGxhc3RQYXltZW50ID0gbmV3IERhdGUobGFzdFBheW1lbnREYXRlKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkaWZmVGltZSA9IE1hdGguYWJzKHRvZGF5LmdldFRpbWUoKSAtIGxhc3RQYXltZW50LmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5jZWlsKGRpZmZUaW1lIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGF0ZSBwZXJpb2RzIGJhc2VkIG9uIGRheXMgbGF0ZSBhbmQgcmVudCBjYWRlbmNlXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZUxhdGVQZXJpb2RzKHRlbmFudCwgZGF5c0xhdGUpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQubGVhc2VzIHx8IHRlbmFudC5sZWFzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGNhZGVuY2UgPSB0ZW5hbnQubGVhc2VzWzBdLnJlbnRfY2FkZW5jZSB8fCAnbW9udGhseSc7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRDYWRlbmNlID0gY2FkZW5jZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgc3dpdGNoIChub3JtYWxpemVkQ2FkZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGRheXNMYXRlIC8gNyk7XG4gICAgICAgICAgICBjYXNlICdiaS13ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYml3ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYmlfd2Vla2x5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGRheXNMYXRlIC8gMTQpO1xuICAgICAgICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoZGF5c0xhdGUgLyAzMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxhdGUgZmVlcyBiYXNlZCBvbiBsYXRlIHBlcmlvZHMgYW5kIHJlbnQgY2FkZW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVMYXRlRmVlcyh0ZW5hbnQsIGxhdGVQZXJpb2RzKSB7XG4gICAgICAgIGlmICghdGVuYW50LmxlYXNlcyB8fCB0ZW5hbnQubGVhc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCBjYWRlbmNlID0gdGVuYW50LmxlYXNlc1swXS5yZW50X2NhZGVuY2UgfHwgJ21vbnRobHknO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGxldCBsYXRlRmVlUGVyUGVyaW9kID0gMDtcbiAgICAgICAgc3dpdGNoIChub3JtYWxpemVkQ2FkZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICAgICAgICBsYXRlRmVlUGVyUGVyaW9kID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaS13ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYml3ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYmlfd2Vla2x5JzpcbiAgICAgICAgICAgICAgICBsYXRlRmVlUGVyUGVyaW9kID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aGx5JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGF0ZUZlZVBlclBlcmlvZCA9IDUwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXRlUGVyaW9kcyAqIGxhdGVGZWVQZXJQZXJpb2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBkdWUgaW5jbHVkaW5nIGxhdGUgZmVlc1xuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbER1ZVdpdGhMYXRlRmVlcyh0ZW5hbnQsIGxhdGVGZWVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VSZW50ID0gdGVuYW50LmxlYXNlcyAmJiB0ZW5hbnQubGVhc2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdGVuYW50LmxlYXNlc1swXS5yZW50XG4gICAgICAgICAgICA6IDA7IC8vIFRPRE86IEltcGxlbWVudCBiYXNlIHJlbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICByZXR1cm4gYmFzZVJlbnQgKyBsYXRlRmVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHdoYXQgYSB0ZW5hbnQgYWN0dWFsbHkgb3dlcyB1c2luZyB0aGUgY3VycmVudGx5X3BhaWRfdXBfZGF0ZVxuICAgICAqIFRoaXMgaXMgdGhlIG5ldyBpbXByb3ZlZCBjYWxjdWxhdGlvbiBzeXN0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVGVuYW50T3dlZEFtb3VudCh0ZW5hbnQpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQubGVhc2VzIHx8IHRlbmFudC5sZWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQZXJpb2RzOiAwLFxuICAgICAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVMZWFzZSA9IHRlbmFudC5sZWFzZXNbMF07XG4gICAgICAgIGlmICghYWN0aXZlTGVhc2UubGVhc2Vfc3RhcnRfZGF0ZSB8fCAhYWN0aXZlTGVhc2UucmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQZXJpb2RzOiAwLFxuICAgICAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZnVsbCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICB0b3RhbExhdGVGZWVzOiAwLFxuICAgICAgICAgICAgbWlzc2VkUGVyaW9kczogMCxcbiAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG90YWwgZGF5cyBsYXRlIGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbERheXNMYXRlKHRlbmFudCkge1xuICAgICAgICBpZiAoIXRlbmFudC5sZWFzZXMgfHwgdGVuYW50LmxlYXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUxlYXNlID0gdGVuYW50LmxlYXNlc1swXTtcbiAgICAgICAgaWYgKCFhY3RpdmVMZWFzZS5sZWFzZV9zdGFydF9kYXRlIHx8ICFhY3RpdmVMZWFzZS5yZW50X2NhZGVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbnRDYWRlbmNlID0gYWN0aXZlTGVhc2UucmVudF9jYWRlbmNlO1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZnVsbCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIEZvciBub3csIHJldHVybiAwIHNpbmNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHBheW1lbnQgaGlzdG9yeVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXRlIGZlZSBhbW91bnQgZm9yIGEgc3BlY2lmaWMgcmVudCBjYWRlbmNlXG4gICAgICovXG4gICAgc3RhdGljIGdldExhdGVGZWVBbW91bnQoY2FkZW5jZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiA0NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHJlbnQgY2FkZW5jZSBmcm9tIHByb3BlcnR5IG5vdGVzXG4gICAgICovXG4gICAgc3RhdGljIGV4dHJhY3RSZW50Q2FkZW5jZShub3Rlcykge1xuICAgICAgICBpZiAoIW5vdGVzKVxuICAgICAgICAgICAgcmV0dXJuICdtb250aGx5JztcbiAgICAgICAgY29uc3QgY2FkZW5jZU1hdGNoID0gbm90ZXMubWF0Y2goL1JlbnQgY2FkZW5jZTpcXHMqKFxcdyspL2kpO1xuICAgICAgICByZXR1cm4gY2FkZW5jZU1hdGNoID8gY2FkZW5jZU1hdGNoWzFdIDogJ21vbnRobHknO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdHdvIGRhdGVzXG4gICAgICovXG4gICAgc3RhdGljIGRheXNCZXR3ZWVuKGRhdGUxLCBkYXRlMikge1xuICAgICAgICBjb25zdCBkMSA9IG5ldyBEYXRlKGRhdGUxKTtcbiAgICAgICAgY29uc3QgZDIgPSBuZXcgRGF0ZShkYXRlMik7XG4gICAgICAgIGNvbnN0IGRpZmZUaW1lID0gTWF0aC5hYnMoZDIuZ2V0VGltZSgpIC0gZDEuZ2V0VGltZSgpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXhwZWN0ZWQgcGF5bWVudCBkYXRlIGZvciBhIHNwZWNpZmljIHBheSBwZXJpb2RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgcGF5UGVyaW9kSW5kZXgsIGNhZGVuY2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUobGVhc2VTdGFydERhdGUpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyAocGF5UGVyaW9kSW5kZXggKiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyAocGF5UGVyaW9kSW5kZXggKiAxNCAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGNhc2UgJ21vbnRobHknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRNb250aChyZXN1bHQuZ2V0TW9udGgoKSArIHBheVBlcmlvZEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBOIGV4cGVjdGVkIHBheW1lbnQgZGF0ZXMgZm9yIGEgdGVuYW50XG4gICAgICovXG4gICAgc3RhdGljIGdldExhc3RFeHBlY3RlZFBheW1lbnREYXRlcyhsZWFzZVN0YXJ0RGF0ZSwgY2FkZW5jZSwgY291bnQgPSAxMikge1xuICAgICAgICBjb25zdCBkYXRlcyA9IFtdO1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIG1vc3QgcmVjZW50IGV4cGVjdGVkIHBheW1lbnQgZGF0ZVxuICAgICAgICBsZXQgY3VycmVudFBlcmlvZCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IHRoaXMuZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgY3VycmVudFBlcmlvZCwgY2FkZW5jZSk7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RGF0ZSA8PSB0b2RheSAmJiBjdXJyZW50UGVyaW9kIDwgY291bnQgKiAyKSB7XG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kKys7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHRoaXMuZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgY3VycmVudFBlcmlvZCwgY2FkZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBsYXN0IE4gcGVyaW9kc1xuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoMCwgY3VycmVudFBlcmlvZCAtIGNvdW50KTsgaSA8IGN1cnJlbnRQZXJpb2Q7IGkrKykge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmdldEV4cGVjdGVkUGF5bWVudERhdGUobGVhc2VTdGFydERhdGUsIGksIGNhZGVuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsYXRlIGZlZXMgZm9yIGEgc3BlY2lmaWMgcGF5IHBlcmlvZFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVMYXRlRmVlc0ZvclBlcmlvZChleHBlY3RlZERhdGUsIHBheW1lbnRIaXN0b3J5LCBjYWRlbmNlLCByZW50QW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGxhdGVGZWVBbW91bnQgPSB0aGlzLmdldExhdGVGZWVBbW91bnQoY2FkZW5jZSk7XG4gICAgICAgIC8vIEZpbmQgcGF5bWVudHMgZm9yIHRoaXMgcGVyaW9kICh3aXRoaW4gNSBkYXlzIG9mIGV4cGVjdGVkIGRhdGUpXG4gICAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoZXhwZWN0ZWREYXRlKTtcbiAgICAgICAgcGVyaW9kU3RhcnQuc2V0RGF0ZShwZXJpb2RTdGFydC5nZXREYXRlKCkgLSAyKTsgLy8gQWxsb3cgMiBkYXlzIGVhcmx5XG4gICAgICAgIGNvbnN0IHBlcmlvZEVuZCA9IG5ldyBEYXRlKGV4cGVjdGVkRGF0ZSk7XG4gICAgICAgIHBlcmlvZEVuZC5zZXREYXRlKHBlcmlvZEVuZC5nZXREYXRlKCkgKyA1KTsgLy8gNSBkYXlzIGdyYWNlIHBlcmlvZFxuICAgICAgICBjb25zdCBwZXJpb2RQYXltZW50cyA9IHBheW1lbnRIaXN0b3J5LmZpbHRlcihwYXltZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnREYXRlID0gbmV3IERhdGUocGF5bWVudC5kYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXltZW50RGF0ZSA+PSBwZXJpb2RTdGFydCAmJiBwYXltZW50RGF0ZSA8PSBwZXJpb2RFbmQgJiYgcGF5bWVudC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG90YWxQYWlkID0gcGVyaW9kUGF5bWVudHMucmVkdWNlKChzdW0sIHBheW1lbnQpID0+IHN1bSArIHBheW1lbnQuYW1vdW50LCAwKTtcbiAgICAgICAgY29uc3Qgb3V0c3RhbmRpbmcgPSBNYXRoLm1heCgwLCByZW50QW1vdW50IC0gdG90YWxQYWlkKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bWVudCBpcyBsYXRlIChhZnRlciBncmFjZSBwZXJpb2QpXG4gICAgICAgIGNvbnN0IGxhc3RQYXltZW50RGF0ZSA9IHBlcmlvZFBheW1lbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gbmV3IERhdGUoTWF0aC5tYXgoLi4ucGVyaW9kUGF5bWVudHMubWFwKHAgPT4gbmV3IERhdGUocC5kYXRlKS5nZXRUaW1lKCkpKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFsYXN0UGF5bWVudERhdGUgfHwgbGFzdFBheW1lbnREYXRlID4gcGVyaW9kRW5kKSB7XG4gICAgICAgICAgICAvLyBQYXltZW50IGlzIGxhdGVcbiAgICAgICAgICAgIGNvbnN0IGRheXNMYXRlID0gbGFzdFBheW1lbnREYXRlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRheXNCZXR3ZWVuKHBlcmlvZEVuZCwgbGFzdFBheW1lbnREYXRlKVxuICAgICAgICAgICAgICAgIDogdGhpcy5kYXlzQmV0d2VlbihwZXJpb2RFbmQsIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0xhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF5c0xhdGU6IE1hdGgubWF4KDAsIGRheXNMYXRlKSxcbiAgICAgICAgICAgICAgICBsYXRlRmVlczogb3V0c3RhbmRpbmcgPiAwID8gbGF0ZUZlZUFtb3VudCA6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxQYWlkLFxuICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xhdGU6IGZhbHNlLFxuICAgICAgICAgICAgZGF5c0xhdGU6IDAsXG4gICAgICAgICAgICBsYXRlRmVlczogMCxcbiAgICAgICAgICAgIHRvdGFsUGFpZCxcbiAgICAgICAgICAgIG91dHN0YW5kaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBsYXRlIHBheW1lbnRzIGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbExhdGVQYXltZW50cyh0ZW5hbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBsYXRlIHBheW1lbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxEdWU6IDAsXG4gICAgICAgICAgICB0b3RhbExhdGVGZWVzOiAwLFxuICAgICAgICAgICAgbGF0ZVBlcmlvZHM6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0ZW5hbnQgaXMgbGF0ZSBvbiBwYXltZW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBpc1RlbmFudExhdGUodGVuYW50LCBwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgbGF0ZSBwYXltZW50IGNoZWNrIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGVuYW50IGJ5IHByb3BlcnR5IGFkZHJlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3ModGVuYW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgcHJvcGVydHkgYnkgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wZXJ0eSwgZXJyb3I6IHByb3BlcnR5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgLmlsaWtlKCdhZGRyZXNzJywgYCUke3RlbmFudERhdGEucHJvcGVydHlfYWRkcmVzc30lYClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsIGBQcm9wZXJ0eSBub3QgZm91bmQgd2l0aCBhZGRyZXNzOiAke3RlbmFudERhdGEucHJvcGVydHlfYWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0ZW5hbnQgd2l0aCBwcm9wZXJ0eV9pZFxuICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0eV9hZGRyZXNzLCAuLi50ZW5hbnRDcmVhdGVEYXRhIH0gPSB0ZW5hbnREYXRhO1xuICAgICAgICAgICAgY29uc3QgdGVuYW50RGF0YVdpdGhQcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgICAgICAuLi50ZW5hbnRDcmVhdGVEYXRhLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5X2lkOiBwcm9wZXJ0eS5pZCxcbiAgICAgICAgICAgICAgICBtb250aGx5X3JlbnQ6IHRlbmFudERhdGEubW9udGhseV9yZW50IHx8IHByb3BlcnR5Lm1vbnRobHlfcmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLmluc2VydChbdGVuYW50RGF0YVdpdGhQcm9wZXJ0eV0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKiwgUkVOVF9wcm9wZXJ0aWVzKG5hbWUsIGFkZHJlc3MpJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVsayBjcmVhdGUgdGVuYW50cyBieSBwcm9wZXJ0eSBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGJ1bGtDcmVhdGVCeVByb3BlcnR5QWRkcmVzcyh0ZW5hbnRzRGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGVuYW50RGF0YSBvZiB0ZW5hbnRzRGF0YSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3ModGVuYW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZC5wdXNoKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBGYWlsZWQgdG8gY3JlYXRlIHRlbmFudCAke3RlbmFudERhdGEuZmlyc3RfbmFtZX0gJHt0ZW5hbnREYXRhLmxhc3RfbmFtZX06ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChgRXJyb3IgY3JlYXRpbmcgdGVuYW50ICR7dGVuYW50RGF0YS5maXJzdF9uYW1lfSAke3RlbmFudERhdGEubGFzdF9uYW1lfTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh7IGNyZWF0ZWQsIGVycm9ycyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBhbW91bnQgb3dlZCBieSBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbEFtb3VudE93ZWQodGVuYW50KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB0b3RhbCBhbW91bnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gMCBzaW5jZSB0aGVzZSBmaWVsZHMgZG9uJ3QgZXhpc3QgaW4gdGhlIGN1cnJlbnQgc2NoZW1hXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlbnQgYW1vdW50IGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZW50QW1vdW50KHRlbmFudCkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcmVudCBhbW91bnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gMCBzaW5jZSBtb250aGx5X3JlbnQgZmllbGQgZG9lc24ndCBleGlzdCBpbiB0aGUgY3VycmVudCBzY2hlbWFcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIHNpbmNlIGxhc3QgcGF5bWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVEYXlzU2luY2VMYXN0UGF5bWVudCh0ZW5hbnQpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGRheXMgc2luY2UgbGFzdCBwYXltZW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIHNpbmNlIGxlYXNlIHN0YXJ0XG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZURheXNTaW5jZUxlYXNlU3RhcnQodGVuYW50KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBkYXlzIHNpbmNlIGxlYXNlIHN0YXJ0IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5UZW5hbnRzU2VydmljZSA9IFRlbmFudHNTZXJ2aWNlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGVuYW50c1NlcnZpY2UiLCJjbGllbnRfMSIsInJlcXVpcmUiLCJnZXRBbGwiLCJmaWx0ZXJzIiwic3VwYWJhc2UiLCJnZXRTdXBhYmFzZUNsaWVudCIsInF1ZXJ5IiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwicHJvcGVydHlfaWQiLCJlcSIsImlzX2FjdGl2ZSIsInVuZGVmaW5lZCIsImxhdGVfc3RhdHVzIiwiZGF0YSIsInRlbmFudHMiLCJlcnJvciIsImNyZWF0ZUFwaVJlc3BvbnNlIiwiaGFuZGxlU3VwYWJhc2VFcnJvciIsInRlbmFudHNXaXRoUmVsYXRpb25zIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInRlbmFudCIsInByb3BlcnR5IiwicHJvcERhdGEiLCJzaW5nbGUiLCJsZWFzZXNEYXRhIiwiaWQiLCJwcm9wZXJ0aWVzIiwibGVhc2VzIiwiZ2V0QnlJZCIsInRlbmFudFdpdGhSZWxhdGlvbnMiLCJjcmVhdGUiLCJ0ZW5hbnREYXRhIiwiY29uc29sZSIsImxvZyIsImluc2VydERhdGEiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZW1haWwiLCJwaG9uZSIsImxlYXNlX3N0YXJ0X2RhdGUiLCJsZWFzZV9lbmRfZGF0ZSIsIm5vdGVzIiwiaW5zZXJ0IiwidXBkYXRlIiwibW9udGhseV9yZW50Iiwic2VjdXJpdHlfZGVwb3NpdCIsInBheW1lbnRfaGlzdG9yeSIsImxhdGVfZmVlc19vd2VkIiwibGFzdF9wYXltZW50X2RhdGUiLCJyZW50X2NhZGVuY2UiLCJmaWx0ZXJlZERhdGEiLCJ1cGRhdGVkVGVuYW50RGF0YSIsInRlbmFudEVycm9yIiwibGVhc2VFcnJvciIsImxpbWl0IiwibGVuZ3RoIiwiYWN0aXZlTGVhc2UiLCJsZWFzZVVwZGF0ZUVycm9yIiwicmVudCIsIndhcm4iLCJ1cGRhdGVkVGVuYW50IiwiZmV0Y2hFcnJvciIsImRlbGV0ZSIsImdldFBhZ2luYXRlZCIsInBhZ2UiLCJvZmZzZXQiLCJjb3VudCIsInJhbmdlIiwidG90YWwiLCJoYXNNb3JlIiwic2VhcmNoIiwic2VhcmNoVGVybSIsIm9yIiwiZ2V0QWN0aXZlIiwiZ2V0TGF0ZSIsIm5lcSIsImdldEJ5UHJvcGVydHkiLCJwcm9wZXJ0eUlkIiwicmVjb3JkUGF5bWVudCIsInRlbmFudElkIiwicGF5bWVudERhdGEiLCJjdXJyZW50VGVuYW50IiwiZ2V0RXJyb3IiLCJnZXRMYXRlVGVuYW50cyIsImNhbGN1bGF0ZVRvdGFsRHVlIiwibGF0ZVBheW1lbnRJbmZvIiwiY2FsY3VsYXRlVG90YWxMYXRlUGF5bWVudHMiLCJ0b3RhbER1ZSIsImNhbGN1bGF0ZURheXNMYXRlIiwibGFzdFBheW1lbnREYXRlIiwibGFzdFBheW1lbnQiLCJEYXRlIiwidG9kYXkiLCJkaWZmVGltZSIsIk1hdGgiLCJhYnMiLCJnZXRUaW1lIiwiZGlmZkRheXMiLCJjZWlsIiwiY2FsY3VsYXRlTGF0ZVBlcmlvZHMiLCJkYXlzTGF0ZSIsImNhZGVuY2UiLCJub3JtYWxpemVkQ2FkZW5jZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsImNhbGN1bGF0ZUxhdGVGZWVzIiwibGF0ZVBlcmlvZHMiLCJsYXRlRmVlUGVyUGVyaW9kIiwiY2FsY3VsYXRlVG90YWxEdWVXaXRoTGF0ZUZlZXMiLCJsYXRlRmVlcyIsImJhc2VSZW50IiwiY2FsY3VsYXRlVGVuYW50T3dlZEFtb3VudCIsInRvdGFsT3dlZCIsInRvdGFsTGF0ZUZlZXMiLCJtaXNzZWRQZXJpb2RzIiwibWlzc2VkUGF5bWVudHMiLCJjYWxjdWxhdGVUb3RhbERheXNMYXRlIiwicmVudENhZGVuY2UiLCJnZXRMYXRlRmVlQW1vdW50IiwiZXh0cmFjdFJlbnRDYWRlbmNlIiwiY2FkZW5jZU1hdGNoIiwibWF0Y2giLCJkYXlzQmV0d2VlbiIsImRhdGUxIiwiZGF0ZTIiLCJkMSIsImQyIiwiZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZSIsImxlYXNlU3RhcnREYXRlIiwicGF5UGVyaW9kSW5kZXgiLCJzdGFydERhdGUiLCJyZXN1bHQiLCJzZXRNb250aCIsImdldE1vbnRoIiwiZ2V0TGFzdEV4cGVjdGVkUGF5bWVudERhdGVzIiwiZGF0ZXMiLCJjdXJyZW50UGVyaW9kIiwiY3VycmVudERhdGUiLCJpIiwibWF4IiwicHVzaCIsImNhbGN1bGF0ZUxhdGVGZWVzRm9yUGVyaW9kIiwiZXhwZWN0ZWREYXRlIiwicGF5bWVudEhpc3RvcnkiLCJyZW50QW1vdW50IiwibGF0ZUZlZUFtb3VudCIsInBlcmlvZFN0YXJ0Iiwic2V0RGF0ZSIsImdldERhdGUiLCJwZXJpb2RFbmQiLCJwZXJpb2RQYXltZW50cyIsImZpbHRlciIsInBheW1lbnQiLCJwYXltZW50RGF0ZSIsImRhdGUiLCJzdGF0dXMiLCJ0b3RhbFBhaWQiLCJyZWR1Y2UiLCJzdW0iLCJhbW91bnQiLCJvdXRzdGFuZGluZyIsInAiLCJpc0xhdGUiLCJpc1RlbmFudExhdGUiLCJjcmVhdGVCeVByb3BlcnR5QWRkcmVzcyIsInByb3BlcnR5RXJyb3IiLCJpbGlrZSIsInByb3BlcnR5X2FkZHJlc3MiLCJ0ZW5hbnRDcmVhdGVEYXRhIiwidGVuYW50RGF0YVdpdGhQcm9wZXJ0eSIsImJ1bGtDcmVhdGVCeVByb3BlcnR5QWRkcmVzcyIsInRlbmFudHNEYXRhIiwiY3JlYXRlZCIsImVycm9ycyIsInN1Y2Nlc3MiLCJjYWxjdWxhdGVUb3RhbEFtb3VudE93ZWQiLCJnZXRSZW50QW1vdW50IiwiY2FsY3VsYXRlRGF5c1NpbmNlTGFzdFBheW1lbnQiLCJjYWxjdWxhdGVEYXlzU2luY2VMZWFzZVN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/api/dist/services/tenants.js\n"));

/***/ })

});