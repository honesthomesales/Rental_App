"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tenants/edit/page",{

/***/ "(app-pages-browser)/../../packages/api/dist/services/tenants.js":
/*!***************************************************!*\
  !*** ../../packages/api/dist/services/tenants.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TenantsService = void 0;\nconst client_1 = __webpack_require__(/*! ../client */ \"(app-pages-browser)/../../packages/api/dist/client.js\");\nclass TenantsService {\n    /**\n     * Get all tenants with optional filtering\n     */ static async getAll(filters) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            let query = supabase.from(\"RENT_tenants\").select(\"*\").order(\"created_at\", {\n                ascending: false\n            });\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get a tenant by ID\n     */ static async getById(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenant, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", id).single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch property\n            let property = null;\n            if (tenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", tenant.property_id).single();\n                property = propData;\n            }\n            // Fetch leases\n            const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                ascending: false\n            });\n            const tenantWithRelations = {\n                ...tenant,\n                properties: property,\n                leases: leasesData || []\n            };\n            return (0, client_1.createApiResponse)(tenantWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Create a new tenant\n     */ static async create(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the data being sent\n            console.log(\"TenantsService.create - Input data:\", tenantData);\n            // Only send the columns that actually exist in the RENT_tenants table\n            const insertData = {\n                property_id: tenantData.property_id,\n                first_name: tenantData.first_name,\n                last_name: tenantData.last_name,\n                email: tenantData.email,\n                phone: tenantData.phone,\n                // monthly_rent: (tenantData as any).monthly_rent, // Temporarily removed due to schema mismatch\n                lease_start_date: tenantData.lease_start_date,\n                lease_end_date: tenantData.lease_end_date,\n                notes: tenantData.notes\n            };\n            console.log(\"TenantsService.create - Insert data (filtered):\", insertData);\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                insertData\n            ]).select(\"*\").single();\n            if (error) {\n                console.error(\"TenantsService.create - Supabase error:\", error);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            console.log(\"TenantsService.create - Success, created tenant:\", data);\n            // Return simple response without additional data for now\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            console.error(\"TenantsService.create - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Update an existing tenant\n     */ static async update(id, tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // Log the update data for debugging\n            console.log(\"TenantsService.update - Updating tenant:\", id, \"with data:\", tenantData);\n            // Filter out fields that don't exist in the RENT_tenants table\n            const { monthly_rent, security_deposit, payment_history, late_fees_owed, late_status, last_payment_date, rent_cadence, ...filteredData } = tenantData;\n            console.log(\"TenantsService.update - Filtered data:\", filteredData);\n            // Update the tenant\n            const { data: updatedTenantData, error: tenantError } = await supabase.from(\"RENT_tenants\").update(filteredData).eq(\"id\", id).select(\"*\").single();\n            if (tenantError) {\n                console.error(\"TenantsService.update - Supabase error:\", tenantError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(tenantError));\n            }\n            // If monthly_rent was updated, also update the corresponding lease\n            if (tenantData.monthly_rent !== undefined && tenantData.monthly_rent !== null) {\n                try {\n                    // Find the active lease for this tenant\n                    const { data: leases, error: leaseError } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", id).eq(\"status\", \"active\").order(\"created_at\", {\n                        ascending: false\n                    }).limit(1);\n                    if (!leaseError && leases && leases.length > 0) {\n                        const activeLease = leases[0];\n                        console.log(\"TenantsService.update - Updating lease rent:\", activeLease.id, \"to:\", tenantData.monthly_rent);\n                        // Update the lease rent\n                        const { error: leaseUpdateError } = await supabase.from(\"RENT_leases\").update({\n                            rent: tenantData.monthly_rent\n                        }).eq(\"id\", activeLease.id);\n                        if (leaseUpdateError) {\n                            console.warn(\"TenantsService.update - Failed to update lease rent:\", leaseUpdateError);\n                        } else {\n                            console.log(\"TenantsService.update - Successfully updated lease rent\");\n                        }\n                    } else {\n                        // No active lease found, create one\n                        console.log(\"TenantsService.update - No active lease found, creating new lease with rent:\", tenantData.monthly_rent);\n                        const { error: leaseCreateError } = await supabase.from(\"RENT_leases\").insert([\n                            {\n                                tenant_id: id,\n                                property_id: updatedTenantData.property_id,\n                                rent: tenantData.monthly_rent,\n                                rent_cadence: \"monthly\",\n                                status: \"active\",\n                                lease_start_date: updatedTenantData.lease_start_date || new Date().toISOString().split(\"T\")[0],\n                                lease_end_date: updatedTenantData.lease_end_date || \"2030-12-31\"\n                            }\n                        ]);\n                        if (leaseCreateError) {\n                            console.warn(\"TenantsService.update - Failed to create new lease:\", leaseCreateError);\n                        } else {\n                            console.log(\"TenantsService.update - Successfully created new lease\");\n                        }\n                    }\n                } catch (leaseUpdateError) {\n                    console.warn(\"TenantsService.update - Error updating lease rent:\", leaseUpdateError);\n                }\n            }\n            // Fetch the updated tenant with leases using the same method as getById\n            const { data: updatedTenant, error: fetchError } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", id).single();\n            if (fetchError) {\n                console.error(\"TenantsService.update - Error fetching updated tenant:\", fetchError);\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(fetchError));\n            }\n            // Fetch property and leases separately (same as getById)\n            let property = null;\n            if (updatedTenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", updatedTenant.property_id).single();\n                property = propData;\n            }\n            // Fetch leases\n            const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", id).order(\"lease_start_date\", {\n                ascending: false\n            });\n            const tenantWithRelations = {\n                ...updatedTenant,\n                properties: property,\n                leases: leasesData || []\n            };\n            return (0, client_1.createApiResponse)(tenantWithRelations);\n        } catch (error) {\n            console.error(\"TenantsService.update - Unexpected error:\", error);\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Delete a tenant\n     */ static async delete(id) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { error } = await supabase.from(\"RENT_tenants\").delete().eq(\"id\", id);\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(true);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get paginated tenants\n     */ static async getPaginated() {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, filters = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const offset = (page - 1) * limit;\n            let query = supabase.from(\"RENT_tenants\").select(\"*\", {\n                count: \"exact\"\n            }).order(\"created_at\", {\n                ascending: false\n            }).range(offset, offset + limit - 1);\n            if (filters === null || filters === void 0 ? void 0 : filters.property_id) {\n                query = query.eq(\"property_id\", filters.property_id);\n            }\n            if ((filters === null || filters === void 0 ? void 0 : filters.is_active) !== undefined) {\n                query = query.eq(\"is_active\", filters.is_active);\n            }\n            if (filters === null || filters === void 0 ? void 0 : filters.late_status) {\n                query = query.eq(\"late_status\", filters.late_status);\n            }\n            const { data: tenants, error, count } = await query;\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)({\n                data: tenantsWithRelations,\n                total: count || 0,\n                page,\n                limit,\n                hasMore: offset + limit < (count || 0)\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Search tenants\n     */ static async search(searchTerm) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").or(\"first_name.ilike.%\".concat(searchTerm, \"%,last_name.ilike.%\").concat(searchTerm, \"%,email.ilike.%\").concat(searchTerm, \"%\")).order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get active tenants\n     */ static async getActive() {\n        return this.getAll({\n            is_active: true\n        });\n    }\n    /**\n     * Get late tenants\n     */ static async getLate() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").neq(\"late_status\", \"on_time\").order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // Fetch properties and leases separately\n            const tenantsWithRelations = await Promise.all(tenants.map(async (tenant)=>{\n                // Fetch property\n                let property = null;\n                if (tenant.property_id) {\n                    const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address\").eq(\"id\", tenant.property_id).single();\n                    property = propData;\n                }\n                // Fetch leases\n                const { data: leasesData } = await supabase.from(\"RENT_leases\").select(\"*\").eq(\"tenant_id\", tenant.id).order(\"lease_start_date\", {\n                    ascending: false\n                });\n                return {\n                    ...tenant,\n                    properties: property,\n                    leases: leasesData || []\n                };\n            }));\n            return (0, client_1.createApiResponse)(tenantsWithRelations);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get tenants by property\n     */ static async getByProperty(propertyId) {\n        return this.getAll({\n            property_id: propertyId\n        });\n    }\n    /**\n     * Record a payment for a tenant\n     */ static async recordPayment(tenantId, paymentData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, get the current tenant with property information\n            const { data: currentTenant, error: getError } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"id\", tenantId).single();\n            if (getError) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(getError));\n            }\n            if (!currentTenant) {\n                return (0, client_1.createApiResponse)(null, \"Tenant not found\");\n            }\n            // Fetch property data separately\n            let property = null;\n            if (currentTenant.property_id) {\n                const { data: propData } = await supabase.from(\"RENT_properties\").select(\"id, name, address, notes, monthly_rent\").eq(\"id\", currentTenant.property_id).single();\n                property = propData;\n            }\n            // TODO: Implement payment recording logic when database schema is updated\n            // For now, just return the tenant as-is\n            return (0, client_1.createApiResponse)(currentTenant);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Get late tenants with detailed information using existing database structure\n     */ static async getLateTenants() {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const { data: tenants, error } = await supabase.from(\"RENT_tenants\").select(\"*\").eq(\"is_active\", true) // Only check active tenants\n            .order(\"created_at\", {\n                ascending: false\n            });\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            // TODO: Implement late tenant logic when database schema is updated\n            // For now, return empty array\n            return (0, client_1.createApiResponse)([]);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount due for a tenant using new pay period logic\n     */ static calculateTotalDue(tenant) {\n        if (!tenant.properties) {\n            // TODO: Implement total due calculation when database schema is updated\n            return 0;\n        }\n        const latePaymentInfo = this.calculateTotalLatePayments(tenant, tenant.properties);\n        return latePaymentInfo.totalDue;\n    }\n    /**\n     * Calculate days late based on last payment date\n     */ static calculateDaysLate(lastPaymentDate) {\n        if (!lastPaymentDate) return 0;\n        const lastPayment = new Date(lastPaymentDate);\n        const today = new Date();\n        const diffTime = Math.abs(today.getTime() - lastPayment.getTime());\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n        return diffDays;\n    }\n    /**\n     * Calculate late periods based on days late and rent cadence\n     */ static calculateLatePeriods(tenant, daysLate) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return Math.ceil(daysLate / 7);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return Math.ceil(daysLate / 14);\n            case \"monthly\":\n            default:\n                return Math.ceil(daysLate / 30);\n        }\n    }\n    /**\n     * Calculate late fees based on late periods and rent cadence\n     */ static calculateLateFees(tenant, latePeriods) {\n        if (!tenant.leases || tenant.leases.length === 0) return 0;\n        const cadence = tenant.leases[0].rent_cadence || \"monthly\";\n        const normalizedCadence = cadence.toLowerCase().trim();\n        let lateFeePerPeriod = 0;\n        switch(normalizedCadence){\n            case \"weekly\":\n                lateFeePerPeriod = 10;\n                break;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                lateFeePerPeriod = 20;\n                break;\n            case \"monthly\":\n            default:\n                lateFeePerPeriod = 50;\n                break;\n        }\n        return latePeriods * lateFeePerPeriod;\n    }\n    /**\n     * Calculate total due including late fees\n     */ static calculateTotalDueWithLateFees(tenant, lateFees) {\n        const baseRent = tenant.leases && tenant.leases.length > 0 ? tenant.leases[0].rent : 0; // TODO: Implement base rent calculation when database schema is updated\n        return baseRent + lateFees;\n    }\n    /**\n     * Calculate what a tenant actually owes using the currently_paid_up_date\n     * This is the new improved calculation system\n     */ static calculateTenantOwedAmount(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            // TODO: Implement calculation when database schema is updated\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent) {\n            return {\n                totalOwed: 0,\n                totalLateFees: 0,\n                missedPeriods: 0,\n                missedPayments: []\n            };\n        }\n        // TODO: Implement full calculation when database schema is updated\n        return {\n            totalOwed: 0,\n            totalLateFees: 0,\n            missedPeriods: 0,\n            missedPayments: []\n        };\n    }\n    /**\n     * Calculate total days late for a tenant\n     */ static calculateTotalDaysLate(tenant) {\n        if (!tenant.leases || tenant.leases.length === 0) {\n            return 0;\n        }\n        const activeLease = tenant.leases[0];\n        if (!activeLease.lease_start_date || !activeLease.rent_cadence) {\n            return 0;\n        }\n        const rentCadence = activeLease.rent_cadence;\n        // TODO: Implement full calculation when database schema is updated\n        // For now, return 0 since we don't have access to payment history\n        return 0;\n    }\n    /**\n     * Get the late fee amount for a specific rent cadence\n     */ static getLateFeeAmount(cadence) {\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return 10;\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return 20;\n            case \"monthly\":\n            default:\n                return 45;\n        }\n    }\n    /**\n     * Extract rent cadence from property notes\n     */ static extractRentCadence(notes) {\n        if (!notes) return \"monthly\";\n        const cadenceMatch = notes.match(/Rent cadence:\\s*(\\w+)/i);\n        return cadenceMatch ? cadenceMatch[1] : \"monthly\";\n    }\n    /**\n     * Calculate the number of days between two dates\n     */ static daysBetween(date1, date2) {\n        const d1 = new Date(date1);\n        const d2 = new Date(date2);\n        const diffTime = Math.abs(d2.getTime() - d1.getTime());\n        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    }\n    /**\n     * Get the expected payment date for a specific pay period\n     */ static getExpectedPaymentDate(leaseStartDate, payPeriodIndex, cadence) {\n        const startDate = new Date(leaseStartDate);\n        const normalizedCadence = cadence.toLowerCase().trim();\n        switch(normalizedCadence){\n            case \"weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 7 * 24 * 60 * 60 * 1000);\n            case \"bi-weekly\":\n            case \"biweekly\":\n            case \"bi_weekly\":\n                return new Date(startDate.getTime() + payPeriodIndex * 14 * 24 * 60 * 60 * 1000);\n            case \"monthly\":\n            default:\n                const result = new Date(startDate);\n                result.setMonth(result.getMonth() + payPeriodIndex);\n                return result;\n        }\n    }\n    /**\n     * Get the last N expected payment dates for a tenant\n     */ static getLastExpectedPaymentDates(leaseStartDate, cadence) {\n        let count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n        const dates = [];\n        const today = new Date();\n        // Find the most recent expected payment date\n        let currentPeriod = 0;\n        let currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        while(currentDate <= today && currentPeriod < count * 2){\n            currentPeriod++;\n            currentDate = this.getExpectedPaymentDate(leaseStartDate, currentPeriod, cadence);\n        }\n        // Get the last N periods\n        for(let i = Math.max(0, currentPeriod - count); i < currentPeriod; i++){\n            dates.push(this.getExpectedPaymentDate(leaseStartDate, i, cadence));\n        }\n        return dates;\n    }\n    /**\n     * Calculate late fees for a specific pay period\n     */ static calculateLateFeesForPeriod(expectedDate, paymentHistory, cadence, rentAmount) {\n        const lateFeeAmount = this.getLateFeeAmount(cadence);\n        // Find payments for this period (within 5 days of expected date)\n        const periodStart = new Date(expectedDate);\n        periodStart.setDate(periodStart.getDate() - 2); // Allow 2 days early\n        const periodEnd = new Date(expectedDate);\n        periodEnd.setDate(periodEnd.getDate() + 5); // 5 days grace period\n        const periodPayments = paymentHistory.filter((payment)=>{\n            const paymentDate = new Date(payment.date);\n            return paymentDate >= periodStart && paymentDate <= periodEnd && payment.status === \"completed\";\n        });\n        const totalPaid = periodPayments.reduce((sum, payment)=>sum + payment.amount, 0);\n        const outstanding = Math.max(0, rentAmount - totalPaid);\n        // Check if payment is late (after grace period)\n        const lastPaymentDate = periodPayments.length > 0 ? new Date(Math.max(...periodPayments.map((p)=>new Date(p.date).getTime()))) : null;\n        if (!lastPaymentDate || lastPaymentDate > periodEnd) {\n            // Payment is late\n            const daysLate = lastPaymentDate ? this.daysBetween(periodEnd, lastPaymentDate) : this.daysBetween(periodEnd, new Date());\n            return {\n                isLate: true,\n                daysLate: Math.max(0, daysLate),\n                lateFees: outstanding > 0 ? lateFeeAmount : 0,\n                totalPaid,\n                outstanding\n            };\n        }\n        return {\n            isLate: false,\n            daysLate: 0,\n            lateFees: 0,\n            totalPaid,\n            outstanding\n        };\n    }\n    /**\n     * Calculate total late payments for a tenant\n     */ static calculateTotalLatePayments(tenant, property) {\n        // TODO: Implement late payment calculation when database schema is updated\n        return {\n            totalDue: 0,\n            totalLateFees: 0,\n            latePeriods: 0\n        };\n    }\n    /**\n     * Check if a tenant is late on payments\n     */ static isTenantLate(tenant, property) {\n        // TODO: Implement late payment check when database schema is updated\n        return false;\n    }\n    /**\n     * Create tenant by property address\n     */ static async createByPropertyAddress(tenantData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            // First, find the property by address\n            const { data: property, error: propertyError } = await supabase.from(\"RENT_properties\").select(\"id, monthly_rent\").ilike(\"address\", \"%\".concat(tenantData.property_address, \"%\")).single();\n            if (propertyError) {\n                return (0, client_1.createApiResponse)(null, \"Property not found with address: \".concat(tenantData.property_address));\n            }\n            // Create tenant with property_id\n            const { property_address, ...tenantCreateData } = tenantData;\n            const tenantDataWithProperty = {\n                ...tenantCreateData,\n                property_id: property.id,\n                monthly_rent: tenantData.monthly_rent || property.monthly_rent\n            };\n            const { data, error } = await supabase.from(\"RENT_tenants\").insert([\n                tenantDataWithProperty\n            ]).select(\"*, RENT_properties(name, address)\").single();\n            if (error) {\n                return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n            }\n            return (0, client_1.createApiResponse)(data);\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Bulk create tenants by property address\n     */ static async bulkCreateByPropertyAddress(tenantsData) {\n        try {\n            const supabase = (0, client_1.getSupabaseClient)();\n            const created = [];\n            const errors = [];\n            for (const tenantData of tenantsData){\n                try {\n                    const result = await this.createByPropertyAddress(tenantData);\n                    if (result.success && result.data) {\n                        created.push(result.data);\n                    } else {\n                        errors.push(\"Failed to create tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(result.error));\n                    }\n                } catch (error) {\n                    errors.push(\"Error creating tenant \".concat(tenantData.first_name, \" \").concat(tenantData.last_name, \": \").concat(error));\n                }\n            }\n            return (0, client_1.createApiResponse)({\n                created,\n                errors\n            });\n        } catch (error) {\n            return (0, client_1.createApiResponse)(null, (0, client_1.handleSupabaseError)(error));\n        }\n    }\n    /**\n     * Calculate total amount owed by a tenant\n     */ static calculateTotalAmountOwed(tenant) {\n        // TODO: Implement total amount calculation when database schema is updated\n        // For now, return 0 since these fields don't exist in the current schema\n        return 0;\n    }\n    /**\n     * Get the rent amount for a tenant\n     */ static getRentAmount(tenant) {\n        // TODO: Implement rent amount calculation when database schema is updated\n        // For now, return 0 since monthly_rent field doesn't exist in the current schema\n        return 0;\n    }\n    /**\n     * Calculate days since last payment\n     */ static calculateDaysSinceLastPayment(tenant) {\n        // TODO: Implement days since last payment calculation when database schema is updated\n        return 0;\n    }\n    /**\n     * Calculate days since lease start\n     */ static calculateDaysSinceLeaseStart(tenant) {\n        // TODO: Implement days since lease start calculation when database schema is updated\n        return 0;\n    }\n}\nexports.TenantsService = TenantsService;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9wYWNrYWdlcy9hcGkvZGlzdC9zZXJ2aWNlcy90ZW5hbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFXO0FBQ3BDLE1BQU1GO0lBQ0Y7O0tBRUMsR0FDRCxhQUFhRyxPQUFPQyxPQUFPLEVBQUU7UUFDekIsSUFBSTtZQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHSixTQUFTSyxpQkFBaUI7WUFDL0MsSUFBSUMsUUFBUUYsU0FDUEcsSUFBSSxDQUFDLGdCQUNMQyxNQUFNLENBQUMsS0FDUEMsS0FBSyxDQUFDLGNBQWM7Z0JBQUVDLFdBQVc7WUFBTTtZQUM1QyxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFdBQVcsRUFBRTtnQkFDdEJMLFFBQVFBLE1BQU1NLEVBQUUsQ0FBQyxlQUFlVCxRQUFRUSxXQUFXO1lBQ3ZEO1lBQ0EsSUFBSVIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTVSxTQUFTLE1BQUtDLFdBQVc7Z0JBQ2xDUixRQUFRQSxNQUFNTSxFQUFFLENBQUMsYUFBYVQsUUFBUVUsU0FBUztZQUNuRDtZQUNBLElBQUlWLG9CQUFBQSw4QkFBQUEsUUFBU1ksV0FBVyxFQUFFO2dCQUN0QlQsUUFBUUEsTUFBTU0sRUFBRSxDQUFDLGVBQWVULFFBQVFZLFdBQVc7WUFDdkQ7WUFDQSxNQUFNLEVBQUVDLE1BQU1DLE9BQU8sRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVo7WUFDdkMsSUFBSVksT0FBTztnQkFDUCxPQUFPLENBQUMsR0FBR2xCLFNBQVNtQixpQkFBaUIsRUFBRSxNQUFNLENBQUMsR0FBR25CLFNBQVNvQixtQkFBbUIsRUFBRUY7WUFDbkY7WUFDQSx5Q0FBeUM7WUFDekMsTUFBTUcsdUJBQXVCLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ04sUUFB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QUksRUFBRTt3QkFDL0JxSyxRQUFRL0IsSUFBSSxDQUFDVCxPQUFPN0gsSUFBSTtvQkFDNUIsT0FDSzt3QkFDRHNLLE9BQU9oQyxJQUFJLENBQUMsMkJBQW9EbEgsT0FBekJBLFdBQVdJLFVBQVUsRUFBQyxLQUE0QnFHLE9BQXpCekcsV0FBV0ssU0FBUyxFQUFDLE1BQWlCLE9BQWJvRyxPQUFPM0gsS0FBSztvQkFDekc7Z0JBQ0osRUFDQSxPQUFPQSxPQUFPO29CQUNWb0ssT0FBT2hDLElBQUksQ0FBQyx5QkFBa0RsSCxPQUF6QkEsV0FBV0ksVUFBVSxFQUFDLEtBQTRCdEIsT0FBekJrQixXQUFXSyxTQUFTLEVBQUMsTUFBVSxPQUFOdkI7Z0JBQzNGO1lBQ0o7WUFDQSxPQUFPLENBQUMsR0FBR2xCLFNBQVNtQixpQkFBaUIsRUFBRTtnQkFBRWtLO2dCQUFTQztZQUFPO1FBQzdELEVBQ0EsT0FBT3BLLE9BQU87WUFDVixPQUFPLENBQUMsR0FBR2xCLFNBQVNtQixpQkFBaUIsRUFBRSxNQUFNLENBQUMsR0FBR25CLFNBQVNvQixtQkFBbUIsRUFBRUY7UUFDbkY7SUFDSjtJQUNBOztLQUVDLEdBQ0QsT0FBT3NLLHlCQUF5Qi9KLE1BQU0sRUFBRTtRQUNwQywyRUFBMkU7UUFDM0UseUVBQXlFO1FBQ3pFLE9BQU87SUFDWDtJQUNBOztLQUVDLEdBQ0QsT0FBT2dLLGNBQWNoSyxNQUFNLEVBQUU7UUFDekIsMEVBQTBFO1FBQzFFLGlGQUFpRjtRQUNqRixPQUFPO0lBQ1g7SUFDQTs7S0FFQyxHQUNELE9BQU9pSyw4QkFBOEJqSyxNQUFNLEVBQUU7UUFDekMsc0ZBQXNGO1FBQ3RGLE9BQU87SUFDWDtJQUNBOztLQUVDLEdBQ0QsT0FBT2tLLDZCQUE2QmxLLE1BQU0sRUFBRTtRQUN4QyxxRkFBcUY7UUFDckYsT0FBTztJQUNYO0FBQ0o7QUFDQTVCLHNCQUFzQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvYXBpL2Rpc3Qvc2VydmljZXMvdGVuYW50cy5qcz9iMzY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZW5hbnRzU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4uL2NsaWVudFwiKTtcbmNsYXNzIFRlbmFudHNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRlbmFudHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0QWxsKGZpbHRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8ucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwcm9wZXJ0eV9pZCcsIGZpbHRlcnMucHJvcGVydHlfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmlzX2FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfYWN0aXZlJywgZmlsdGVycy5pc19hY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmxhdGVfc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnbGF0ZV9zdGF0dXMnLCBmaWx0ZXJzLmxhdGVfc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MsIG5vdGVzLCBtb250aGx5X3JlbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdGVuYW50IGJ5IElEXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEJ5SWQoaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB0ZW5hbnQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRlbmFudC5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgYWRkcmVzcywgbm90ZXMsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGxlYXNlc0RhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ3RlbmFudF9pZCcsIHRlbmFudC5pZClcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRXaXRoUmVsYXRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRlbmFudCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh0ZW5hbnRXaXRoUmVsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0ZW5hbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHRlbmFudERhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgLy8gTG9nIHRoZSBkYXRhIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS5jcmVhdGUgLSBJbnB1dCBkYXRhOicsIHRlbmFudERhdGEpO1xuICAgICAgICAgICAgLy8gT25seSBzZW5kIHRoZSBjb2x1bW5zIHRoYXQgYWN0dWFsbHkgZXhpc3QgaW4gdGhlIFJFTlRfdGVuYW50cyB0YWJsZVxuICAgICAgICAgICAgY29uc3QgaW5zZXJ0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eV9pZDogdGVuYW50RGF0YS5wcm9wZXJ0eV9pZCxcbiAgICAgICAgICAgICAgICBmaXJzdF9uYW1lOiB0ZW5hbnREYXRhLmZpcnN0X25hbWUsXG4gICAgICAgICAgICAgICAgbGFzdF9uYW1lOiB0ZW5hbnREYXRhLmxhc3RfbmFtZSxcbiAgICAgICAgICAgICAgICBlbWFpbDogdGVuYW50RGF0YS5lbWFpbCxcbiAgICAgICAgICAgICAgICBwaG9uZTogdGVuYW50RGF0YS5waG9uZSxcbiAgICAgICAgICAgICAgICAvLyBtb250aGx5X3JlbnQ6ICh0ZW5hbnREYXRhIGFzIGFueSkubW9udGhseV9yZW50LCAvLyBUZW1wb3JhcmlseSByZW1vdmVkIGR1ZSB0byBzY2hlbWEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgICBsZWFzZV9zdGFydF9kYXRlOiB0ZW5hbnREYXRhLmxlYXNlX3N0YXJ0X2RhdGUsXG4gICAgICAgICAgICAgICAgbGVhc2VfZW5kX2RhdGU6IHRlbmFudERhdGEubGVhc2VfZW5kX2RhdGUsXG4gICAgICAgICAgICAgICAgbm90ZXM6IHRlbmFudERhdGEubm90ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gSW5zZXJ0IGRhdGEgKGZpbHRlcmVkKTonLCBpbnNlcnREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLmluc2VydChbaW5zZXJ0RGF0YV0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGVuYW50c1NlcnZpY2UuY3JlYXRlIC0gU3VwYWJhc2UgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLmNyZWF0ZSAtIFN1Y2Nlc3MsIGNyZWF0ZWQgdGVuYW50OicsIGRhdGEpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIHNpbXBsZSByZXNwb25zZSB3aXRob3V0IGFkZGl0aW9uYWwgZGF0YSBmb3Igbm93XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RlbmFudHNTZXJ2aWNlLmNyZWF0ZSAtIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyB1cGRhdGUoaWQsIHRlbmFudERhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgLy8gTG9nIHRoZSB1cGRhdGUgZGF0YSBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gVXBkYXRpbmcgdGVuYW50OicsIGlkLCAnd2l0aCBkYXRhOicsIHRlbmFudERhdGEpO1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBmaWVsZHMgdGhhdCBkb24ndCBleGlzdCBpbiB0aGUgUkVOVF90ZW5hbnRzIHRhYmxlXG4gICAgICAgICAgICBjb25zdCB7IG1vbnRobHlfcmVudCwgLy8gUmVtb3ZlIHRoaXMgc2luY2UgaXQncyBjYXVzaW5nIHRoZSBlcnJvclxuICAgICAgICAgICAgc2VjdXJpdHlfZGVwb3NpdCwgcGF5bWVudF9oaXN0b3J5LCBsYXRlX2ZlZXNfb3dlZCwgbGF0ZV9zdGF0dXMsIGxhc3RfcGF5bWVudF9kYXRlLCByZW50X2NhZGVuY2UsIC4uLmZpbHRlcmVkRGF0YSB9ID0gdGVuYW50RGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBGaWx0ZXJlZCBkYXRhOicsIGZpbHRlcmVkRGF0YSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRlbmFudFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB1cGRhdGVkVGVuYW50RGF0YSwgZXJyb3I6IHRlbmFudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZmlsdGVyZWREYXRhKVxuICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAodGVuYW50RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBTdXBhYmFzZSBlcnJvcjonLCB0ZW5hbnRFcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKHRlbmFudEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtb250aGx5X3JlbnQgd2FzIHVwZGF0ZWQsIGFsc28gdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIGxlYXNlXG4gICAgICAgICAgICBpZiAodGVuYW50RGF0YS5tb250aGx5X3JlbnQgIT09IHVuZGVmaW5lZCAmJiB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGFjdGl2ZSBsZWFzZSBmb3IgdGhpcyB0ZW5hbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXMsIGVycm9yOiBsZWFzZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCBpZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5saW1pdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFzZUVycm9yICYmIGxlYXNlcyAmJiBsZWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlTGVhc2UgPSBsZWFzZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gVXBkYXRpbmcgbGVhc2UgcmVudDonLCBhY3RpdmVMZWFzZS5pZCwgJ3RvOicsIHRlbmFudERhdGEubW9udGhseV9yZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVhc2UgcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogbGVhc2VVcGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGUoeyByZW50OiB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBhY3RpdmVMZWFzZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVhc2VVcGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGVuYW50c1NlcnZpY2UudXBkYXRlIC0gRmFpbGVkIHRvIHVwZGF0ZSBsZWFzZSByZW50OicsIGxlYXNlVXBkYXRlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIFN1Y2Nlc3NmdWxseSB1cGRhdGVkIGxlYXNlIHJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFjdGl2ZSBsZWFzZSBmb3VuZCwgY3JlYXRlIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIE5vIGFjdGl2ZSBsZWFzZSBmb3VuZCwgY3JlYXRpbmcgbmV3IGxlYXNlIHdpdGggcmVudDonLCB0ZW5hbnREYXRhLm1vbnRobHlfcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiBsZWFzZUNyZWF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX2xlYXNlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydChbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV9pZDogdXBkYXRlZFRlbmFudERhdGEucHJvcGVydHlfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbnQ6IHRlbmFudERhdGEubW9udGhseV9yZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW50X2NhZGVuY2U6ICdtb250aGx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhc2Vfc3RhcnRfZGF0ZTogdXBkYXRlZFRlbmFudERhdGEubGVhc2Vfc3RhcnRfZGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhc2VfZW5kX2RhdGU6IHVwZGF0ZWRUZW5hbnREYXRhLmxlYXNlX2VuZF9kYXRlIHx8ICcyMDMwLTEyLTMxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWFzZUNyZWF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBGYWlsZWQgdG8gY3JlYXRlIG5ldyBsZWFzZTonLCBsZWFzZUNyZWF0ZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBTdWNjZXNzZnVsbHkgY3JlYXRlZCBuZXcgbGVhc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAobGVhc2VVcGRhdGVFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIEVycm9yIHVwZGF0aW5nIGxlYXNlIHJlbnQ6JywgbGVhc2VVcGRhdGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHVwZGF0ZWQgdGVuYW50IHdpdGggbGVhc2VzIHVzaW5nIHRoZSBzYW1lIG1ldGhvZCBhcyBnZXRCeUlkXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHVwZGF0ZWRUZW5hbnQsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZmV0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RlbmFudHNTZXJ2aWNlLnVwZGF0ZSAtIEVycm9yIGZldGNoaW5nIHVwZGF0ZWQgdGVuYW50OicsIGZldGNoRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShmZXRjaEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0eSBhbmQgbGVhc2VzIHNlcGFyYXRlbHkgKHNhbWUgYXMgZ2V0QnlJZClcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlZFRlbmFudC5wcm9wZXJ0eV9pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZSwgYWRkcmVzcywgbm90ZXMsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB1cGRhdGVkVGVuYW50LnByb3BlcnR5X2lkKVxuICAgICAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZldGNoIGxlYXNlc1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX2xlYXNlcycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCBpZClcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRXaXRoUmVsYXRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRUZW5hbnQsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgbGVhc2VzOiBsZWFzZXNEYXRhIHx8IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50V2l0aFJlbGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUZW5hbnRzU2VydmljZS51cGRhdGUgLSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBkZWxldGUoaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgICAgICAuZXEoJ2lkJywgaWQpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwYWdpbmF0ZWQgdGVuYW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRQYWdpbmF0ZWQocGFnZSA9IDEsIGxpbWl0ID0gMTAsIGZpbHRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1cGFiYXNlID0gKDAsIGNsaWVudF8xLmdldFN1cGFiYXNlQ2xpZW50KSgpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHBhZ2UgLSAxKSAqIGxpbWl0O1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJywgeyBjb3VudDogJ2V4YWN0JyB9KVxuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgIC5yYW5nZShvZmZzZXQsIG9mZnNldCArIGxpbWl0IC0gMSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVycz8ucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwcm9wZXJ0eV9pZCcsIGZpbHRlcnMucHJvcGVydHlfaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmlzX2FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfYWN0aXZlJywgZmlsdGVycy5pc19hY3RpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlcnM/LmxhdGVfc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnbGF0ZV9zdGF0dXMnLCBmaWx0ZXJzLmxhdGVfc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBxdWVyeTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydGllcyBhbmQgbGVhc2VzIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIGNvbnN0IHRlbmFudHNXaXRoUmVsYXRpb25zID0gYXdhaXQgUHJvbWlzZS5hbGwodGVuYW50cy5tYXAoYXN5bmMgKHRlbmFudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGVuYW50LnByb3BlcnR5X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcHJvcERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCBhZGRyZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcSgnaWQnLCB0ZW5hbnQucHJvcGVydHlfaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZldGNoIGxlYXNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogbGVhc2VzRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfbGVhc2VzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgICAgIC5lcSgndGVuYW50X2lkJywgdGVuYW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAub3JkZXIoJ2xlYXNlX3N0YXJ0X2RhdGUnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGVuYW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGVhc2VzOiBsZWFzZXNEYXRhIHx8IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZW5hbnRzV2l0aFJlbGF0aW9ucyxcbiAgICAgICAgICAgICAgICB0b3RhbDogY291bnQgfHwgMCxcbiAgICAgICAgICAgICAgICBwYWdlLFxuICAgICAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgICAgIGhhc01vcmU6IG9mZnNldCArIGxpbWl0IDwgKGNvdW50IHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHNlYXJjaChzZWFyY2hUZXJtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLm9yKGBmaXJzdF9uYW1lLmlsaWtlLiUke3NlYXJjaFRlcm19JSxsYXN0X25hbWUuaWxpa2UuJSR7c2VhcmNoVGVybX0lLGVtYWlsLmlsaWtlLiUke3NlYXJjaFRlcm19JWApXG4gICAgICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjdGl2ZSB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldEFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKHsgaXNfYWN0aXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGF0ZSB0ZW5hbnRzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldExhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdXBhYmFzZSA9ICgwLCBjbGllbnRfMS5nZXRTdXBhYmFzZUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdGVuYW50cywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgICAgICAgICAgLm5lcSgnbGF0ZV9zdGF0dXMnLCAnb25fdGltZScpXG4gICAgICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwcm9wZXJ0aWVzIGFuZCBsZWFzZXMgc2VwYXJhdGVseVxuICAgICAgICAgICAgY29uc3QgdGVuYW50c1dpdGhSZWxhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW5hbnRzLm1hcChhc3luYyAodGVuYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0ZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3Byb3BlcnRpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKCdpZCcsIHRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggbGVhc2VzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBsZWFzZXNEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9sZWFzZXMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAgICAgLmVxKCd0ZW5hbnRfaWQnLCB0ZW5hbnQuaWQpXG4gICAgICAgICAgICAgICAgICAgIC5vcmRlcignbGVhc2Vfc3RhcnRfZGF0ZScsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50ZW5hbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsZWFzZXM6IGxlYXNlc0RhdGEgfHwgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkodGVuYW50c1dpdGhSZWxhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRlbmFudHMgYnkgcHJvcGVydHlcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0QnlQcm9wZXJ0eShwcm9wZXJ0eUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbCh7IHByb3BlcnR5X2lkOiBwcm9wZXJ0eUlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgYSBwYXltZW50IGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByZWNvcmRQYXltZW50KHRlbmFudElkLCBwYXltZW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZ2V0IHRoZSBjdXJyZW50IHRlbmFudCB3aXRoIHByb3BlcnR5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRUZW5hbnQsIGVycm9yOiBnZXRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF90ZW5hbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ2lkJywgdGVuYW50SWQpXG4gICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgaWYgKGdldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGdldEVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRUZW5hbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAnVGVuYW50IG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmV0Y2ggcHJvcGVydHkgZGF0YSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZW5hbnQucHJvcGVydHlfaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHByb3BEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgICAgICAuZnJvbSgnUkVOVF9wcm9wZXJ0aWVzJylcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGFkZHJlc3MsIG5vdGVzLCBtb250aGx5X3JlbnQnKVxuICAgICAgICAgICAgICAgICAgICAuZXEoJ2lkJywgY3VycmVudFRlbmFudC5wcm9wZXJ0eV9pZClcbiAgICAgICAgICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcGF5bWVudCByZWNvcmRpbmcgbG9naWMgd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgLy8gRm9yIG5vdywganVzdCByZXR1cm4gdGhlIHRlbmFudCBhcy1pc1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkoY3VycmVudFRlbmFudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbGF0ZSB0ZW5hbnRzIHdpdGggZGV0YWlsZWQgaW5mb3JtYXRpb24gdXNpbmcgZXhpc3RpbmcgZGF0YWJhc2Ugc3RydWN0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdldExhdGVUZW5hbnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHRlbmFudHMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdSRU5UX3RlbmFudHMnKVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAgICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSkgLy8gT25seSBjaGVjayBhY3RpdmUgdGVuYW50c1xuICAgICAgICAgICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGxhdGUgdGVuYW50IGxvZ2ljIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIEZvciBub3csIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkoW10pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCBkdWUgZm9yIGEgdGVuYW50IHVzaW5nIG5ldyBwYXkgcGVyaW9kIGxvZ2ljXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZVRvdGFsRHVlKHRlbmFudCkge1xuICAgICAgICBpZiAoIXRlbmFudC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgdG90YWwgZHVlIGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhdGVQYXltZW50SW5mbyA9IHRoaXMuY2FsY3VsYXRlVG90YWxMYXRlUGF5bWVudHModGVuYW50LCB0ZW5hbnQucHJvcGVydGllcyk7XG4gICAgICAgIHJldHVybiBsYXRlUGF5bWVudEluZm8udG90YWxEdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIGxhdGUgYmFzZWQgb24gbGFzdCBwYXltZW50IGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlRGF5c0xhdGUobGFzdFBheW1lbnREYXRlKSB7XG4gICAgICAgIGlmICghbGFzdFBheW1lbnREYXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGxhc3RQYXltZW50ID0gbmV3IERhdGUobGFzdFBheW1lbnREYXRlKTtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkaWZmVGltZSA9IE1hdGguYWJzKHRvZGF5LmdldFRpbWUoKSAtIGxhc3RQYXltZW50LmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IGRpZmZEYXlzID0gTWF0aC5jZWlsKGRpZmZUaW1lIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGF0ZSBwZXJpb2RzIGJhc2VkIG9uIGRheXMgbGF0ZSBhbmQgcmVudCBjYWRlbmNlXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZUxhdGVQZXJpb2RzKHRlbmFudCwgZGF5c0xhdGUpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQubGVhc2VzIHx8IHRlbmFudC5sZWFzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGNhZGVuY2UgPSB0ZW5hbnQubGVhc2VzWzBdLnJlbnRfY2FkZW5jZSB8fCAnbW9udGhseSc7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRDYWRlbmNlID0gY2FkZW5jZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgc3dpdGNoIChub3JtYWxpemVkQ2FkZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGRheXNMYXRlIC8gNyk7XG4gICAgICAgICAgICBjYXNlICdiaS13ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYml3ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYmlfd2Vla2x5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGRheXNMYXRlIC8gMTQpO1xuICAgICAgICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoZGF5c0xhdGUgLyAzMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxhdGUgZmVlcyBiYXNlZCBvbiBsYXRlIHBlcmlvZHMgYW5kIHJlbnQgY2FkZW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVMYXRlRmVlcyh0ZW5hbnQsIGxhdGVQZXJpb2RzKSB7XG4gICAgICAgIGlmICghdGVuYW50LmxlYXNlcyB8fCB0ZW5hbnQubGVhc2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCBjYWRlbmNlID0gdGVuYW50LmxlYXNlc1swXS5yZW50X2NhZGVuY2UgfHwgJ21vbnRobHknO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGxldCBsYXRlRmVlUGVyUGVyaW9kID0gMDtcbiAgICAgICAgc3dpdGNoIChub3JtYWxpemVkQ2FkZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnd2Vla2x5JzpcbiAgICAgICAgICAgICAgICBsYXRlRmVlUGVyUGVyaW9kID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaS13ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYml3ZWVrbHknOlxuICAgICAgICAgICAgY2FzZSAnYmlfd2Vla2x5JzpcbiAgICAgICAgICAgICAgICBsYXRlRmVlUGVyUGVyaW9kID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aGx5JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGF0ZUZlZVBlclBlcmlvZCA9IDUwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXRlUGVyaW9kcyAqIGxhdGVGZWVQZXJQZXJpb2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBkdWUgaW5jbHVkaW5nIGxhdGUgZmVlc1xuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbER1ZVdpdGhMYXRlRmVlcyh0ZW5hbnQsIGxhdGVGZWVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2VSZW50ID0gdGVuYW50LmxlYXNlcyAmJiB0ZW5hbnQubGVhc2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdGVuYW50LmxlYXNlc1swXS5yZW50XG4gICAgICAgICAgICA6IDA7IC8vIFRPRE86IEltcGxlbWVudCBiYXNlIHJlbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICByZXR1cm4gYmFzZVJlbnQgKyBsYXRlRmVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHdoYXQgYSB0ZW5hbnQgYWN0dWFsbHkgb3dlcyB1c2luZyB0aGUgY3VycmVudGx5X3BhaWRfdXBfZGF0ZVxuICAgICAqIFRoaXMgaXMgdGhlIG5ldyBpbXByb3ZlZCBjYWxjdWxhdGlvbiBzeXN0ZW1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlVGVuYW50T3dlZEFtb3VudCh0ZW5hbnQpIHtcbiAgICAgICAgaWYgKCF0ZW5hbnQubGVhc2VzIHx8IHRlbmFudC5sZWFzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQZXJpb2RzOiAwLFxuICAgICAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmVMZWFzZSA9IHRlbmFudC5sZWFzZXNbMF07XG4gICAgICAgIGlmICghYWN0aXZlTGVhc2UubGVhc2Vfc3RhcnRfZGF0ZSB8fCAhYWN0aXZlTGVhc2UucmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxMYXRlRmVlczogMCxcbiAgICAgICAgICAgICAgICBtaXNzZWRQZXJpb2RzOiAwLFxuICAgICAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZnVsbCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3RhbE93ZWQ6IDAsXG4gICAgICAgICAgICB0b3RhbExhdGVGZWVzOiAwLFxuICAgICAgICAgICAgbWlzc2VkUGVyaW9kczogMCxcbiAgICAgICAgICAgIG1pc3NlZFBheW1lbnRzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG90YWwgZGF5cyBsYXRlIGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbERheXNMYXRlKHRlbmFudCkge1xuICAgICAgICBpZiAoIXRlbmFudC5sZWFzZXMgfHwgdGVuYW50LmxlYXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGl2ZUxlYXNlID0gdGVuYW50LmxlYXNlc1swXTtcbiAgICAgICAgaWYgKCFhY3RpdmVMZWFzZS5sZWFzZV9zdGFydF9kYXRlIHx8ICFhY3RpdmVMZWFzZS5yZW50X2NhZGVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbnRDYWRlbmNlID0gYWN0aXZlTGVhc2UucmVudF9jYWRlbmNlO1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZnVsbCBjYWxjdWxhdGlvbiB3aGVuIGRhdGFiYXNlIHNjaGVtYSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIEZvciBub3csIHJldHVybiAwIHNpbmNlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHBheW1lbnQgaGlzdG9yeVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXRlIGZlZSBhbW91bnQgZm9yIGEgc3BlY2lmaWMgcmVudCBjYWRlbmNlXG4gICAgICovXG4gICAgc3RhdGljIGdldExhdGVGZWVBbW91bnQoY2FkZW5jZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICAgICAgY2FzZSAnbW9udGhseSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiA0NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHJlbnQgY2FkZW5jZSBmcm9tIHByb3BlcnR5IG5vdGVzXG4gICAgICovXG4gICAgc3RhdGljIGV4dHJhY3RSZW50Q2FkZW5jZShub3Rlcykge1xuICAgICAgICBpZiAoIW5vdGVzKVxuICAgICAgICAgICAgcmV0dXJuICdtb250aGx5JztcbiAgICAgICAgY29uc3QgY2FkZW5jZU1hdGNoID0gbm90ZXMubWF0Y2goL1JlbnQgY2FkZW5jZTpcXHMqKFxcdyspL2kpO1xuICAgICAgICByZXR1cm4gY2FkZW5jZU1hdGNoID8gY2FkZW5jZU1hdGNoWzFdIDogJ21vbnRobHknO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdHdvIGRhdGVzXG4gICAgICovXG4gICAgc3RhdGljIGRheXNCZXR3ZWVuKGRhdGUxLCBkYXRlMikge1xuICAgICAgICBjb25zdCBkMSA9IG5ldyBEYXRlKGRhdGUxKTtcbiAgICAgICAgY29uc3QgZDIgPSBuZXcgRGF0ZShkYXRlMik7XG4gICAgICAgIGNvbnN0IGRpZmZUaW1lID0gTWF0aC5hYnMoZDIuZ2V0VGltZSgpIC0gZDEuZ2V0VGltZSgpKTtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChkaWZmVGltZSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXhwZWN0ZWQgcGF5bWVudCBkYXRlIGZvciBhIHNwZWNpZmljIHBheSBwZXJpb2RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgcGF5UGVyaW9kSW5kZXgsIGNhZGVuY2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUobGVhc2VTdGFydERhdGUpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ2FkZW5jZSA9IGNhZGVuY2UudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHN3aXRjaCAobm9ybWFsaXplZENhZGVuY2UpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyAocGF5UGVyaW9kSW5kZXggKiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgY2FzZSAnYmktd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2Jpd2Vla2x5JzpcbiAgICAgICAgICAgIGNhc2UgJ2JpX3dlZWtseSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRUaW1lKCkgKyAocGF5UGVyaW9kSW5kZXggKiAxNCAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGNhc2UgJ21vbnRobHknOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRNb250aChyZXN1bHQuZ2V0TW9udGgoKSArIHBheVBlcmlvZEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBOIGV4cGVjdGVkIHBheW1lbnQgZGF0ZXMgZm9yIGEgdGVuYW50XG4gICAgICovXG4gICAgc3RhdGljIGdldExhc3RFeHBlY3RlZFBheW1lbnREYXRlcyhsZWFzZVN0YXJ0RGF0ZSwgY2FkZW5jZSwgY291bnQgPSAxMikge1xuICAgICAgICBjb25zdCBkYXRlcyA9IFtdO1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIG1vc3QgcmVjZW50IGV4cGVjdGVkIHBheW1lbnQgZGF0ZVxuICAgICAgICBsZXQgY3VycmVudFBlcmlvZCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IHRoaXMuZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgY3VycmVudFBlcmlvZCwgY2FkZW5jZSk7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RGF0ZSA8PSB0b2RheSAmJiBjdXJyZW50UGVyaW9kIDwgY291bnQgKiAyKSB7XG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kKys7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHRoaXMuZ2V0RXhwZWN0ZWRQYXltZW50RGF0ZShsZWFzZVN0YXJ0RGF0ZSwgY3VycmVudFBlcmlvZCwgY2FkZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBsYXN0IE4gcGVyaW9kc1xuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoMCwgY3VycmVudFBlcmlvZCAtIGNvdW50KTsgaSA8IGN1cnJlbnRQZXJpb2Q7IGkrKykge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmdldEV4cGVjdGVkUGF5bWVudERhdGUobGVhc2VTdGFydERhdGUsIGksIGNhZGVuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBsYXRlIGZlZXMgZm9yIGEgc3BlY2lmaWMgcGF5IHBlcmlvZFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVMYXRlRmVlc0ZvclBlcmlvZChleHBlY3RlZERhdGUsIHBheW1lbnRIaXN0b3J5LCBjYWRlbmNlLCByZW50QW1vdW50KSB7XG4gICAgICAgIGNvbnN0IGxhdGVGZWVBbW91bnQgPSB0aGlzLmdldExhdGVGZWVBbW91bnQoY2FkZW5jZSk7XG4gICAgICAgIC8vIEZpbmQgcGF5bWVudHMgZm9yIHRoaXMgcGVyaW9kICh3aXRoaW4gNSBkYXlzIG9mIGV4cGVjdGVkIGRhdGUpXG4gICAgICAgIGNvbnN0IHBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoZXhwZWN0ZWREYXRlKTtcbiAgICAgICAgcGVyaW9kU3RhcnQuc2V0RGF0ZShwZXJpb2RTdGFydC5nZXREYXRlKCkgLSAyKTsgLy8gQWxsb3cgMiBkYXlzIGVhcmx5XG4gICAgICAgIGNvbnN0IHBlcmlvZEVuZCA9IG5ldyBEYXRlKGV4cGVjdGVkRGF0ZSk7XG4gICAgICAgIHBlcmlvZEVuZC5zZXREYXRlKHBlcmlvZEVuZC5nZXREYXRlKCkgKyA1KTsgLy8gNSBkYXlzIGdyYWNlIHBlcmlvZFxuICAgICAgICBjb25zdCBwZXJpb2RQYXltZW50cyA9IHBheW1lbnRIaXN0b3J5LmZpbHRlcihwYXltZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnREYXRlID0gbmV3IERhdGUocGF5bWVudC5kYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXltZW50RGF0ZSA+PSBwZXJpb2RTdGFydCAmJiBwYXltZW50RGF0ZSA8PSBwZXJpb2RFbmQgJiYgcGF5bWVudC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG90YWxQYWlkID0gcGVyaW9kUGF5bWVudHMucmVkdWNlKChzdW0sIHBheW1lbnQpID0+IHN1bSArIHBheW1lbnQuYW1vdW50LCAwKTtcbiAgICAgICAgY29uc3Qgb3V0c3RhbmRpbmcgPSBNYXRoLm1heCgwLCByZW50QW1vdW50IC0gdG90YWxQYWlkKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bWVudCBpcyBsYXRlIChhZnRlciBncmFjZSBwZXJpb2QpXG4gICAgICAgIGNvbnN0IGxhc3RQYXltZW50RGF0ZSA9IHBlcmlvZFBheW1lbnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gbmV3IERhdGUoTWF0aC5tYXgoLi4ucGVyaW9kUGF5bWVudHMubWFwKHAgPT4gbmV3IERhdGUocC5kYXRlKS5nZXRUaW1lKCkpKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFsYXN0UGF5bWVudERhdGUgfHwgbGFzdFBheW1lbnREYXRlID4gcGVyaW9kRW5kKSB7XG4gICAgICAgICAgICAvLyBQYXltZW50IGlzIGxhdGVcbiAgICAgICAgICAgIGNvbnN0IGRheXNMYXRlID0gbGFzdFBheW1lbnREYXRlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRheXNCZXR3ZWVuKHBlcmlvZEVuZCwgbGFzdFBheW1lbnREYXRlKVxuICAgICAgICAgICAgICAgIDogdGhpcy5kYXlzQmV0d2VlbihwZXJpb2RFbmQsIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0xhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF5c0xhdGU6IE1hdGgubWF4KDAsIGRheXNMYXRlKSxcbiAgICAgICAgICAgICAgICBsYXRlRmVlczogb3V0c3RhbmRpbmcgPiAwID8gbGF0ZUZlZUFtb3VudCA6IDAsXG4gICAgICAgICAgICAgICAgdG90YWxQYWlkLFxuICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xhdGU6IGZhbHNlLFxuICAgICAgICAgICAgZGF5c0xhdGU6IDAsXG4gICAgICAgICAgICBsYXRlRmVlczogMCxcbiAgICAgICAgICAgIHRvdGFsUGFpZCxcbiAgICAgICAgICAgIG91dHN0YW5kaW5nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBsYXRlIHBheW1lbnRzIGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbExhdGVQYXltZW50cyh0ZW5hbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBsYXRlIHBheW1lbnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxEdWU6IDAsXG4gICAgICAgICAgICB0b3RhbExhdGVGZWVzOiAwLFxuICAgICAgICAgICAgbGF0ZVBlcmlvZHM6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0ZW5hbnQgaXMgbGF0ZSBvbiBwYXltZW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBpc1RlbmFudExhdGUodGVuYW50LCBwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgbGF0ZSBwYXltZW50IGNoZWNrIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGVuYW50IGJ5IHByb3BlcnR5IGFkZHJlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3ModGVuYW50RGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgcHJvcGVydHkgYnkgYWRkcmVzc1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBwcm9wZXJ0eSwgZXJyb3I6IHByb3BlcnR5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfcHJvcGVydGllcycpXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnaWQsIG1vbnRobHlfcmVudCcpXG4gICAgICAgICAgICAgICAgLmlsaWtlKCdhZGRyZXNzJywgYCUke3RlbmFudERhdGEucHJvcGVydHlfYWRkcmVzc30lYClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsIGBQcm9wZXJ0eSBub3QgZm91bmQgd2l0aCBhZGRyZXNzOiAke3RlbmFudERhdGEucHJvcGVydHlfYWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0ZW5hbnQgd2l0aCBwcm9wZXJ0eV9pZFxuICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0eV9hZGRyZXNzLCAuLi50ZW5hbnRDcmVhdGVEYXRhIH0gPSB0ZW5hbnREYXRhO1xuICAgICAgICAgICAgY29uc3QgdGVuYW50RGF0YVdpdGhQcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgICAgICAuLi50ZW5hbnRDcmVhdGVEYXRhLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5X2lkOiBwcm9wZXJ0eS5pZCxcbiAgICAgICAgICAgICAgICBtb250aGx5X3JlbnQ6IHRlbmFudERhdGEubW9udGhseV9yZW50IHx8IHByb3BlcnR5Lm1vbnRobHlfcmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLmZyb20oJ1JFTlRfdGVuYW50cycpXG4gICAgICAgICAgICAgICAgLmluc2VydChbdGVuYW50RGF0YVdpdGhQcm9wZXJ0eV0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgnKiwgUkVOVF9wcm9wZXJ0aWVzKG5hbWUsIGFkZHJlc3MpJylcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKShudWxsLCAoMCwgY2xpZW50XzEuaGFuZGxlU3VwYWJhc2VFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjbGllbnRfMS5jcmVhdGVBcGlSZXNwb25zZSkobnVsbCwgKDAsIGNsaWVudF8xLmhhbmRsZVN1cGFiYXNlRXJyb3IpKGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVsayBjcmVhdGUgdGVuYW50cyBieSBwcm9wZXJ0eSBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGJ1bGtDcmVhdGVCeVByb3BlcnR5QWRkcmVzcyh0ZW5hbnRzRGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2UgPSAoMCwgY2xpZW50XzEuZ2V0U3VwYWJhc2VDbGllbnQpKCk7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGVuYW50RGF0YSBvZiB0ZW5hbnRzRGF0YSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY3JlYXRlQnlQcm9wZXJ0eUFkZHJlc3ModGVuYW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZC5wdXNoKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGBGYWlsZWQgdG8gY3JlYXRlIHRlbmFudCAke3RlbmFudERhdGEuZmlyc3RfbmFtZX0gJHt0ZW5hbnREYXRhLmxhc3RfbmFtZX06ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChgRXJyb3IgY3JlYXRpbmcgdGVuYW50ICR7dGVuYW50RGF0YS5maXJzdF9uYW1lfSAke3RlbmFudERhdGEubGFzdF9uYW1lfTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNsaWVudF8xLmNyZWF0ZUFwaVJlc3BvbnNlKSh7IGNyZWF0ZWQsIGVycm9ycyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xpZW50XzEuY3JlYXRlQXBpUmVzcG9uc2UpKG51bGwsICgwLCBjbGllbnRfMS5oYW5kbGVTdXBhYmFzZUVycm9yKShlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b3RhbCBhbW91bnQgb3dlZCBieSBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUb3RhbEFtb3VudE93ZWQodGVuYW50KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB0b3RhbCBhbW91bnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gMCBzaW5jZSB0aGVzZSBmaWVsZHMgZG9uJ3QgZXhpc3QgaW4gdGhlIGN1cnJlbnQgc2NoZW1hXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlbnQgYW1vdW50IGZvciBhIHRlbmFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZW50QW1vdW50KHRlbmFudCkge1xuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgcmVudCBhbW91bnQgY2FsY3VsYXRpb24gd2hlbiBkYXRhYmFzZSBzY2hlbWEgaXMgdXBkYXRlZFxuICAgICAgICAvLyBGb3Igbm93LCByZXR1cm4gMCBzaW5jZSBtb250aGx5X3JlbnQgZmllbGQgZG9lc24ndCBleGlzdCBpbiB0aGUgY3VycmVudCBzY2hlbWFcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIHNpbmNlIGxhc3QgcGF5bWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVEYXlzU2luY2VMYXN0UGF5bWVudCh0ZW5hbnQpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGRheXMgc2luY2UgbGFzdCBwYXltZW50IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkYXlzIHNpbmNlIGxlYXNlIHN0YXJ0XG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZURheXNTaW5jZUxlYXNlU3RhcnQodGVuYW50KSB7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBkYXlzIHNpbmNlIGxlYXNlIHN0YXJ0IGNhbGN1bGF0aW9uIHdoZW4gZGF0YWJhc2Ugc2NoZW1hIGlzIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5UZW5hbnRzU2VydmljZSA9IFRlbmFudHNTZXJ2aWNlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGVuYW50c1NlcnZpY2UiLCJjbGllbnRfMSIsInJlcXVpcmUiLCJnZXRBbGwiLCJmaWx0ZXJzIiwic3VwYWJhc2UiLCJnZXRTdXBhYmFzZUNsaWVudCIsInF1ZXJ5IiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwicHJvcGVydHlfaWQiLCJlcSIsImlzX2FjdGl2ZSIsInVuZGVmaW5lZCIsImxhdGVfc3RhdHVzIiwiZGF0YSIsInRlbmFudHMiLCJlcnJvciIsImNyZWF0ZUFwaVJlc3BvbnNlIiwiaGFuZGxlU3VwYWJhc2VFcnJvciIsInRlbmFudHNXaXRoUmVsYXRpb25zIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInRlbmFudCIsInByb3BlcnR5IiwicHJvcERhdGEiLCJzaW5nbGUiLCJsZWFzZXNEYXRhIiwiaWQiLCJwcm9wZXJ0aWVzIiwibGVhc2VzIiwiZ2V0QnlJZCIsInRlbmFudFdpdGhSZWxhdGlvbnMiLCJjcmVhdGUiLCJ0ZW5hbnREYXRhIiwiY29uc29sZSIsImxvZyIsImluc2VydERhdGEiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZW1haWwiLCJwaG9uZSIsImxlYXNlX3N0YXJ0X2RhdGUiLCJsZWFzZV9lbmRfZGF0ZSIsIm5vdGVzIiwiaW5zZXJ0IiwidXBkYXRlIiwibW9udGhseV9yZW50Iiwic2VjdXJpdHlfZGVwb3NpdCIsInBheW1lbnRfaGlzdG9yeSIsImxhdGVfZmVlc19vd2VkIiwibGFzdF9wYXltZW50X2RhdGUiLCJyZW50X2NhZGVuY2UiLCJmaWx0ZXJlZERhdGEiLCJ1cGRhdGVkVGVuYW50RGF0YSIsInRlbmFudEVycm9yIiwibGVhc2VFcnJvciIsImxpbWl0IiwibGVuZ3RoIiwiYWN0aXZlTGVhc2UiLCJsZWFzZVVwZGF0ZUVycm9yIiwicmVudCIsIndhcm4iLCJsZWFzZUNyZWF0ZUVycm9yIiwidGVuYW50X2lkIiwic3RhdHVzIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ1cGRhdGVkVGVuYW50IiwiZmV0Y2hFcnJvciIsImRlbGV0ZSIsImdldFBhZ2luYXRlZCIsInBhZ2UiLCJvZmZzZXQiLCJjb3VudCIsInJhbmdlIiwidG90YWwiLCJoYXNNb3JlIiwic2VhcmNoIiwic2VhcmNoVGVybSIsIm9yIiwiZ2V0QWN0aXZlIiwiZ2V0TGF0ZSIsIm5lcSIsImdldEJ5UHJvcGVydHkiLCJwcm9wZXJ0eUlkIiwicmVjb3JkUGF5bWVudCIsInRlbmFudElkIiwicGF5bWVudERhdGEiLCJjdXJyZW50VGVuYW50IiwiZ2V0RXJyb3IiLCJnZXRMYXRlVGVuYW50cyIsImNhbGN1bGF0ZVRvdGFsRHVlIiwibGF0ZVBheW1lbnRJbmZvIiwiY2FsY3VsYXRlVG90YWxMYXRlUGF5bWVudHMiLCJ0b3RhbER1ZSIsImNhbGN1bGF0ZURheXNMYXRlIiwibGFzdFBheW1lbnREYXRlIiwibGFzdFBheW1lbnQiLCJ0b2RheSIsImRpZmZUaW1lIiwiTWF0aCIsImFicyIsImdldFRpbWUiLCJkaWZmRGF5cyIsImNlaWwiLCJjYWxjdWxhdGVMYXRlUGVyaW9kcyIsImRheXNMYXRlIiwiY2FkZW5jZSIsIm5vcm1hbGl6ZWRDYWRlbmNlIiwidG9Mb3dlckNhc2UiLCJ0cmltIiwiY2FsY3VsYXRlTGF0ZUZlZXMiLCJsYXRlUGVyaW9kcyIsImxhdGVGZWVQZXJQZXJpb2QiLCJjYWxjdWxhdGVUb3RhbER1ZVdpdGhMYXRlRmVlcyIsImxhdGVGZWVzIiwiYmFzZVJlbnQiLCJjYWxjdWxhdGVUZW5hbnRPd2VkQW1vdW50IiwidG90YWxPd2VkIiwidG90YWxMYXRlRmVlcyIsIm1pc3NlZFBlcmlvZHMiLCJtaXNzZWRQYXltZW50cyIsImNhbGN1bGF0ZVRvdGFsRGF5c0xhdGUiLCJyZW50Q2FkZW5jZSIsImdldExhdGVGZWVBbW91bnQiLCJleHRyYWN0UmVudENhZGVuY2UiLCJjYWRlbmNlTWF0Y2giLCJtYXRjaCIsImRheXNCZXR3ZWVuIiwiZGF0ZTEiLCJkYXRlMiIsImQxIiwiZDIiLCJnZXRFeHBlY3RlZFBheW1lbnREYXRlIiwibGVhc2VTdGFydERhdGUiLCJwYXlQZXJpb2RJbmRleCIsInN0YXJ0RGF0ZSIsInJlc3VsdCIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJnZXRMYXN0RXhwZWN0ZWRQYXltZW50RGF0ZXMiLCJkYXRlcyIsImN1cnJlbnRQZXJpb2QiLCJjdXJyZW50RGF0ZSIsImkiLCJtYXgiLCJwdXNoIiwiY2FsY3VsYXRlTGF0ZUZlZXNGb3JQZXJpb2QiLCJleHBlY3RlZERhdGUiLCJwYXltZW50SGlzdG9yeSIsInJlbnRBbW91bnQiLCJsYXRlRmVlQW1vdW50IiwicGVyaW9kU3RhcnQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsInBlcmlvZEVuZCIsInBlcmlvZFBheW1lbnRzIiwiZmlsdGVyIiwicGF5bWVudCIsInBheW1lbnREYXRlIiwiZGF0ZSIsInRvdGFsUGFpZCIsInJlZHVjZSIsInN1bSIsImFtb3VudCIsIm91dHN0YW5kaW5nIiwicCIsImlzTGF0ZSIsImlzVGVuYW50TGF0ZSIsImNyZWF0ZUJ5UHJvcGVydHlBZGRyZXNzIiwicHJvcGVydHlFcnJvciIsImlsaWtlIiwicHJvcGVydHlfYWRkcmVzcyIsInRlbmFudENyZWF0ZURhdGEiLCJ0ZW5hbnREYXRhV2l0aFByb3BlcnR5IiwiYnVsa0NyZWF0ZUJ5UHJvcGVydHlBZGRyZXNzIiwidGVuYW50c0RhdGEiLCJjcmVhdGVkIiwiZXJyb3JzIiwic3VjY2VzcyIsImNhbGN1bGF0ZVRvdGFsQW1vdW50T3dlZCIsImdldFJlbnRBbW91bnQiLCJjYWxjdWxhdGVEYXlzU2luY2VMYXN0UGF5bWVudCIsImNhbGN1bGF0ZURheXNTaW5jZUxlYXNlU3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../packages/api/dist/services/tenants.js\n"));

/***/ })

});